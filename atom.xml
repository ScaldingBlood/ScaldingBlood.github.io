<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rock &#39;n&#39; Roll will break your heart.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lavaoxsea.com/"/>
  <updated>2020-01-03T18:55:11.062Z</updated>
  <id>http://lavaoxsea.com/</id>
  
  <author>
    <name>paz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>toy-spring总结</title>
    <link href="http://lavaoxsea.com/2019/10/27/toy-spring%E6%80%BB%E7%BB%93/"/>
    <id>http://lavaoxsea.com/2019/10/27/toy-spring总结/</id>
    <published>2019-10-27T09:48:35.000Z</published>
    <updated>2020-01-03T18:55:11.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>面试需要，翻了下Spring原理，主要设计ioc和aop部分的知识。其中有个简化的Spring源码实现叫<a href="http://www.tianxiaobo.com/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8A%E7%AF%87/" target="_blank" rel="noopener">toy-spring</a>。读了下，对两者的实现原理有了些认识，简单总结下。</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>Bean之间的依赖关系不再由Bean自己控制，而是交给Spring来管理，在需要使用相应的bean时由Spring提供。具体控制和管理这些Bean的是<code>BeanFactory</code>的实现，使用其暴露的<code>getBean</code>方法进行调用。在<code>BeanFactory</code>的实现中存在一个保存了bean与id的映射的map，从而实现bean的查找与注入。</p><h5 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h5><p>管理的bean是懒加载的，通过著名的<code>BeanDefinition</code>来实现。具体来说，toy-spring有一个<code>XmlBeanFactory</code>的实现类，也就是说，需要加载的类可以在xml文件中定义。<code>XmlBeanFactory</code>会使用<code>XmlBeanReader</code>解析定义的bean，并把解析出来的内容作为<code>BeanDefinition</code>的实例。<code>XmlBeanFactory</code>会获取<code>XmlBeanReader</code>解析得到的<code>BeanDefinition</code>与id的map。之后在调用<code>getBean</code>方法时，会先在<code>BeanDefinition</code>中查找是否存在对应bean的饮用，若不存在则未被加载过。通过<code>BeanDefinition</code>中定义的类型信息创建新实例，并通过反射调用set方法，把<code>BeanDefinition</code>中记录的属性信息设置到实例中。如果存在引用类型的属性，则递归进行解析再设置属性。<code>BeanDefinition</code>中的引用属性信息通过单独的类型进行记录，同于和值属性的类型进行区分。最后把实例保存在<code>BeanDefinition</code>中并返回。</p><h5 id="Aware的注入"><a href="#Aware的注入" class="headerlink" title="Aware的注入"></a>Aware的注入</h5><p>通过是否实现<code>BeanFactoryAware</code>借口来判断是否需要注入BeanFactory实现从而使得被注入的bean可以借助其<code>getBean</code>方法来加载bean。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>切面的设计更加巧妙和复杂一些。其利用了动态代理的技术，从而可以修改原有类方法的调用实现。即存在两个类，一个是原有类，另一个是切入的类。通过动态代理Proxy生成第三个类。在这里主要是在原有方法被调用时，在执行方法之前会先执行切面中定义的方法。项目中使用的是JDK提供的动态代理技术。切入的类需要实现<code>InvocationHandler</code>接口。代理类通过<code>Proxy.newProxyInstance</code>生成。</p><h5 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h5><p>切面(Aspect)由切点(Pointcut)和通知(Advice)组成。这里的通知借助AspectJ的<code>MethodInterceptor</code>来实现，通知中通过<code>MethodInvocation</code>来调用原有对象方法。</p><h5 id="在Spring中使用AOP"><a href="#在Spring中使用AOP" class="headerlink" title="在Spring中使用AOP"></a>在Spring中使用AOP</h5><p>在Spring中使用AOP也即能够在加载类的时候根据条件织入相应的切面，另外实现切面、<code>MethodInterceptor</code>、通知等bean的管理。<br>首先是相关bean的管理：和其他的bean加载类似，一样由<code>BeanFactory</code>管理，并由bean的类型来将相应类型的切面bean都加载出来。具体来说，会把我们实现的通知实例化并注入切面。然后根据传入的切点表达式，生成切点对象。包括类型过滤和方法匹配去实现织入的判定。</p><p>织入切面则是借助了<code>BeanPostProcessor</code>接口来实现。在<code>BeanFactory</code>在实例化bean之后，在返回之前，将遍历所有实现了<code>BeanPostProcessor</code>接口的bean，并调用其<code>postProcessAfterInitialization</code>方法。在这里我们实现动态代理的生成并返回。具体来说，项目中<code>AspectJAwareAdvisorAutoProxyCreator</code>实现了<code>BeanPostProcessor</code>接口，并且实现了<code>BeanFactoryAware</code>接口使用<code>BeanFactory</code>加载所有的切面对象。遍历所有的切面，寻找是否存在类匹配的对象。若存在，创建<code>AdvisedSupport</code>对象传入切面的方法过滤器、通知、和具体bean的实例、类型、接口信息。代理工厂会把<code>AdvisedSupport</code>传给<code>JdkDynamicAopProxy</code>获取实际的代理类并返回。从而完成方法的织入。</p><h3 id="Outro"><a href="#Outro" class="headerlink" title="Outro"></a>Outro</h3><p>总体来说toyspring的技术还是很简单的，但是类的依赖继承关系有点杂乱，我稍微整理了下放在我的<img src="https://github.com/scaldingblood" alt="仓库">内。关注点分离和接耦的思想在大型项目中的地位还是很高的，便于设计出清晰易于扩展的系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;&lt;p&gt;面试需要，翻了下Spring原理，主要设计ioc和aop部分的知识。其中有个简化的Spring源码实现叫&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第五届阿里中间件性能挑战赛总结(初赛)</title>
    <link href="http://lavaoxsea.com/2019/07/27/%E7%AC%AC%E4%BA%94%E5%B1%8A%E9%98%BF%E9%87%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93(%E5%88%9D%E8%B5%9B)/"/>
    <id>http://lavaoxsea.com/2019/07/27/第五届阿里中间件性能挑战赛总结(初赛)/</id>
    <published>2019-07-26T17:07:24.000Z</published>
    <updated>2019-07-28T18:26:35.407Z</updated>
    
    <content type="html"><![CDATA[<p><img src="logo.png" alt=""></p><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>第五届中间件比赛也准时开始了。这次初赛的<a href="https://tianchi.aliyun.com/competition/entrance/231714/information" target="_blank" rel="noopener">题目</a>是要设计一个负载均衡的服务，提供给dubbo进行RPC的调用。初赛其实也花了不少时间，最后成绩也很不理想。其实是到了最后一天最后一次尝试进的复赛，非常巧合了可以说。我的架构也不是最优的，这里仅供参考，也会有大佬们的思路介绍。代码已经推到我的<a href="https://github.com/ScaldingBlood/ali-competition-adaptive-loadbalance" target="_blank" rel="noopener">github仓库</a>中。</p><h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>简单描述一下。评测给我们提供了三台硬件配置不同的服务器，并且分别在上面提供了RPC接口。其中每个服务器上Dubbo的线程池大小是不同的，当挤压的请求数量超过负载则会跑出线程池满的异常并作为一个失败请求。<br>此外为了模拟动态变化的服务能力，每个dubbo服务都做了最大并发量的限制并且消息的消费时间也是动态变化的，每一段时间变化一次。其中最大并发数小于线程池的大小，它会限制同时能够处理请求的数量并使多剩余的请求进入队列排队。而消费时间服从指数分布，变化的是其期望值。<br>目标是由wrk向在另一台服务器压测，依据成功请求数进行排名。压测模拟1024个连接同时发请求。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>事实上在题目发出不久后，官方就发了一版题意分析，其中提到了三个待解决的问题：</p><ul><li>如何对服务进行容量评估</li><li>如果应用评估结果，即如何维护provider对应的服务状态，又如何进行决策</li><li>辅助接口的利用</li></ul><p>以上其实也就是本题的核心，我简单讲解一下我的思路：</p><h5 id="辅助接口"><a href="#辅助接口" class="headerlink" title="辅助接口"></a>辅助接口</h5><p>这里借助了dubbo的底层实现，实现的功能是服务端可以向客户端发起回调。实现的逻辑是客户端，即这里的gateway，向服务端，即这里的provider提供一个<code>CallbackListener</code>的接口，客户端可以通过其中的<code>receiveServerMsg</code>处理收到回调的逻辑。而服务端则需要实现<code>CallbackServiceImpl</code>接口，通过<code>addListener</code>获取客户端的stub，从而执行回调逻辑。<br>这个设计很巧妙并且实用，这里我们直接拿过来用就可以了。官方给了一个示例，用Timer每5秒回调一次provider。这里回调具体的用法需要和架构实现相符，之后再讨论。</p><h5 id="容量评估"><a href="#容量评估" class="headerlink" title="容量评估"></a>容量评估</h5><p>这里的容量评估其实包括两个方面，一方面是provider能够提供的负载能力的评估，另一方面是provider当前消费消息能力的评估。</p><h6 id="统计服务端负载情况"><a href="#统计服务端负载情况" class="headerlink" title="统计服务端负载情况"></a>统计服务端负载情况</h6><p>在每个provider上运行的dubbo示例都有最大线程数限制，一旦把接收消息的数量超过最大线程数，就会把provider打挂。因此需要在consumer端做流量控制的处理，当然在provier中也提供了一个用于限流的接口，但是它会将这个请求变为一个失败请求，因此这里考虑在consumer做限流回报更高。</p><p>这里我参考了provider控制最大并发数的实现，利用信号量去实现。信号量基于AQS实现，是一种高效控制资源的工具。简单来说，当接收到请求，获取一个信号量，而返回响应的时候进行释放。题目在consumer端提供了过滤器接口，但是最初我不知道可以从过滤器中判断是发向了那个provider，所以设计了一个批量release的方案。<br>具体来说，在gateway每次向provider发送请求之后就获取一个信号量，然后provider处理完请求后，会累计处理完请求的数量，每当数量达到BATCH_SIZE后，会回调gateway释放BATCH_SIZE个信号量并将处理完请求的数量置0。这里批量释放信号量的做法，有个明显的好处，可以减少释放时的线程同步造成的阻塞，但也会造成一个有些隐蔽的问题。当gateway收到不满一个BATCH_SIZE数量的消息时，它不会释放这些信号量，也就是说，gateway端如果有新的请求打进来，provider其实已经可以处理这些请求了，但是由于信号量没有被释放，因此阻塞住了，从而导致整体性能的下跌。</p><p>当使用gateway的过滤器来执行信号量的释放后，以上问题就已经解决了，但是由于信号量可能存在大量的并发操作，也会导致性能下跌。解决方案是使用AtomicInteger来统计连接数。但是AtomicInteger也存在无法控制最大并行数的问题，可以理解为信号量用完后无法阻塞的问题，在代码中添加一个while死循环来处理没有可用线程时的等待。但是这个策略本身似乎仍不能绝对保证不超过最大并行数，需要之后配合调用策略使之成立。</p><h6 id="评估服务端处理消息能力"><a href="#评估服务端处理消息能力" class="headerlink" title="评估服务端处理消息能力"></a>评估服务端处理消息能力</h6><p>处理消息的能力由两方面决定，一方面是当前provider处理消息耗时的期望，另一方面是当前provider等待消息的数量。第一个方面比较好理解，因为消息是服从指数分布的，而这个分布的期望是动态变化的，与硬件配置、最大并发量和最大线程数都不相关。而第二个等待消息的数量则是说，由于最大并发数限制但是没有超过最大线程数而进入队列等待的消息的数量，这些消息会等当前处理中的消息处理完之后在进行处理，也可以认为它的处理时间是未等待消息的两倍。</p><p>由于我们无法直接获取到当前的配置，因此需要自行评估。一个直观的前提条件是需要统计一条消息的执行时间，在provider端也有一个过滤器，把消息放到Map中，统计进入和取出的时间差就可以作为这条消息消费的耗时。由于消息的消费时间是由指数分布算出来的，因此单条消息是的消费时间是没有价值的，我们需要统计一批消息来估计provider消费消息的大概时长。</p><p>这里我做了一个优化，由于是统计一批消息的时长，因此我认为可以不去严格统计每一条消息的耗时。具体来说，在provider中维护一个队列，每次有消息进入就会把当前时间放进队列尾端，而消息处理完以后则会从队列头中取出时间戳，和当前时间的差值近似作为这条消息的耗时。这是在统计批量消息的基础上的一个假设。我认为它有两个好处，一是不在维护消息的map，减少系统开销；二是平滑因指数分布造成消息耗时的波动。</p><p>另外，当我们拿到一批消息的耗时后如何估算指数分布的期望，或者说是服务能力。这里有两个考虑，一是使用中位数。由指数分布的特性，中位数除以lg2即可得其期望。另一种方式是直接使用平均数，因为除了服从指数分布的消息外，还存在一些排队消息。另外平均数计算时的开销更小。在赛后群里的讨论的时候，有人提出说可以通过统计短处理延时请求的数量来作为判断依据，而且效果远好于简单取均值。</p><h5 id="应用评估结果决策"><a href="#应用评估结果决策" class="headerlink" title="应用评估结果决策"></a>应用评估结果决策</h5><p>当我们拿到provider的性能后如何分配请求是相当重要的，可以认为在同一时刻有1024个请求打到gateway中。这一块的实现应该会差异很大，我的设计相对简单。每次回调会携带目标provider由批量消息计算出的耗时，在gateway这端会维持住这个状态。另外，我们给每个provider设置一个最小发送请求的阈值，即饥饿值，当没有达到这个数量时，请求会优先发给这个provider。当三个provider都不饥饿时，则会依据维持的耗时进行判断，优先选择耗时小的，直到达到其上限，再选择耗时第二短的provider发送请求。</p><p>这种方法看起来有点傻，但是也是有其考虑的。因为当你向耗时最快的provider发送了过量请求后，会有部分请求进入队列排队，从而拖慢该provider的耗时，使其他的provider可以处理消息。但是也存在一个问题，provider耗时信息的回调是不及时的，也就是说当得到耗时变慢的回调时，可能provider早就已经处于过载的状态。因此，回调的时机也很关键。在我的方案中回调的时机是由当前还未处理完的请求的数量决定的，这个数量可以认为是最大并发数加上排队消息的数量。当这些请求处理完以后，再开始计算接下来这些数量的请求加上可能新增请求数量的总计数量的消息耗时并回调。</p><p>此外，我给每个provider设置了一个上界upper，当某个provider请求数超过上界时会优先给其他没有超过上界的provider发送请求，当都达到上界时会再依照上面的逻辑决策。这样的设计会给我们提供动态调配provider负载的能力，也就是说可以将处理能力强/消息消费耗时短的provider的上界提高，而把目前处理能力差的provider的上界拉低。这个判断逻辑同样放在回调时处理，不过设置了一个判断条件，即当三个provider都回调过一次之后才会进行调整，防止某个provider的权重很低并且一直得不到回调从而被其他回调快的privoder一直降低upper。</p><h5 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h5><p>流水线处理消息：在provider端维护了一个队列，和后台一个线程。计算出的每条耗时信息都会放入对垒中，线程会不断从队列中获取耗时并计算数量，当达到回调数量后会将数量置0并回调。整个过程时异步的，不会阻塞消息处理逻辑。</p><h3 id="大佬思路分享"><a href="#大佬思路分享" class="headerlink" title="大佬思路分享"></a>大佬思路分享</h3><p>单纯基于provider剩余线程数(总线程-工作线程)进行分配似乎也可以达到一个不错的成绩。</p><p>基于回压的<a href="https://mp.weixin.qq.com/s/hGTBRfdivxFCqJ-c4gPVaw" target="_blank" rel="noopener">方案</a>，利用<code>ConcurrentSkipListSet</code>构造了一个带有取出尾部元素的优先队列数据结构，具体可以看大佬的文章和代码，还是很有意思的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;&lt;p&gt;第五届中间件比赛也准时开始了。这次初赛的&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Apache工具类源码阅读</title>
    <link href="http://lavaoxsea.com/2019/05/08/Apache%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://lavaoxsea.com/2019/05/08/Apache工具类源码阅读/</id>
    <published>2019-05-08T13:37:08.000Z</published>
    <updated>2019-05-20T17:31:21.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>常用的有commons-lang3 commons-io commons-collections，工具类并没有复杂的结构，阅读起来简单。很适合学习优秀的代码习惯和细节。文中简要挑一些类说明。</p><h2 id="commons-lang3"><a href="#commons-lang3" class="headerlink" title="commons-lang3"></a>commons-lang3</h2><p>这个包主要扩展了java.lang，提供一些常用操作。</p><h4 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h4><p><code>String</code>是不可变的，因此对String的修改操作都是返回新建的字符串。此外，类中用到了需要变长参数，如<code>isAnyEmpty(final CharSequence... css)</code>，可以避免调用时需要创建数组或者List。本质上是一个语法糖，由调用时创建数组传入。</p><h5 id="去除"><a href="#去除" class="headerlink" title="去除"></a>去除</h5><ul><li>trim </li><li>truncate </li><li>strip</li></ul><p>传入目标str和stripStr，将str头尾中在stripStr中出现的字符去除，stripStr为null默认去除空格。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stripStart</span><span class="params">(<span class="keyword">final</span> String str, <span class="keyword">final</span> String stripChars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> strLen; <span class="comment">// str长度</span></span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || (strLen = str.length()) == <span class="number">0</span>) &#123; <span class="comment">// 判断时赋值</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">// 第一个不在stripChars中的字符</span></span><br><span class="line">    <span class="keyword">if</span> (stripChars == <span class="keyword">null</span>) &#123; <span class="comment">// 去除空格的情况</span></span><br><span class="line">        <span class="keyword">while</span> (start != strLen &amp;&amp; Character.isWhitespace(str.charAt(start))) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stripChars.isEmpty()) &#123; <span class="comment">// 不去除。没有这个判断也可以执行，用于避免搜一遍字符串。</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start != strLen &amp;&amp; stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.substring(start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><ul><li>equals</li><li>compare</li></ul><p>都是传入两个或以上的字符串比较，考虑了空和null的情况。之后调用原生api。</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul><li>indexOf</li><li>ordinalIndexOf</li><li>contains</li><li>indexOfAnyBut</li><li>containsAny</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找出现第ordinal次searchStr的位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ordinalIndexOf</span><span class="params">(<span class="keyword">final</span> CharSequence str, <span class="keyword">final</span> CharSequence searchStr, <span class="keyword">final</span> <span class="keyword">int</span> ordinal, <span class="keyword">final</span> <span class="keyword">boolean</span> lastIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || searchStr == <span class="keyword">null</span> || ordinal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INDEX_NOT_FOUND; <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (searchStr.length() == <span class="number">0</span>) &#123; <span class="comment">// 查找的串为空</span></span><br><span class="line">        <span class="keyword">return</span> lastIndex ? str.length() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// set the initial index beyond the end of the string</span></span><br><span class="line">    <span class="comment">// this is to allow for the initial index decrement/increment</span></span><br><span class="line">    <span class="keyword">int</span> index = lastIndex ? str.length() : INDEX_NOT_FOUND;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastIndex) &#123;</span><br><span class="line">            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - <span class="number">1</span>); <span class="comment">// step backwards thru string</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = CharSequenceUtils.indexOf(str, searchStr, index + <span class="number">1</span>); <span class="comment">// step forwards through string</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> index; <span class="comment">// 没找到or数量不够</span></span><br><span class="line">        &#125;</span><br><span class="line">        found++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (found &lt; ordinal);</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="子串-修改"><a href="#子串-修改" class="headerlink" title="子串/修改"></a>子串/修改</h5><ul><li>substring</li><li>left / mid / right</li><li>substringBefore / substringAfter / substringBetween</li><li>split</li><li>join</li><li>removeStart</li><li>replace</li><li>replaceChars</li><li>repeat</li><li>rotate</li><li>reverse</li><li>abbreviate</li><li>wrap</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] splitByWholeSeparatorWorker(</span><br><span class="line">        <span class="keyword">final</span> String str, <span class="keyword">final</span> String separator, <span class="keyword">final</span> <span class="keyword">int</span> max, <span class="keyword">final</span> <span class="keyword">boolean</span> preserveAllTokens) &#123;</span><br><span class="line">    <span class="comment">//... null空判断省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> separatorLength = separator.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;String&gt; substrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> numberOfSubstrings = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> beg = <span class="number">0</span>; <span class="comment">// 开始位置标记</span></span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>; <span class="comment">// 结束位置标记</span></span><br><span class="line">    <span class="keyword">while</span> (end &lt; len) &#123;</span><br><span class="line">        end = str.indexOf(separator, beg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end &gt; -<span class="number">1</span>) &#123; <span class="comment">// 找到</span></span><br><span class="line">            <span class="keyword">if</span> (end &gt; beg) &#123; <span class="comment">// ！begin是否等于end，也即处理两个speratorStr相连</span></span><br><span class="line">                numberOfSubstrings += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (numberOfSubstrings == max) &#123; <span class="comment">// 数量达到max，子串取到尾</span></span><br><span class="line">                    end = len;</span><br><span class="line">                    substrings.add(str.substring(beg));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    substrings.add(str.substring(beg, end));</span><br><span class="line">                    beg = end + separatorLength; <span class="comment">// 下次搜素起始位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We found a consecutive occurrence of the separator, so skip it.</span></span><br><span class="line">                <span class="keyword">if</span> (preserveAllTokens) &#123; <span class="comment">// 保留两个相连speartorStr之间的空串EMPTY("")</span></span><br><span class="line">                    numberOfSubstrings += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (numberOfSubstrings == max) &#123;</span><br><span class="line">                        end = len;</span><br><span class="line">                        substrings.add(str.substring(beg));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        substrings.add(EMPTY);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                beg = end + separatorLength;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// String.substring( beg ) goes from 'beg' to the end of the String.</span></span><br><span class="line">            substrings.add(str.substring(beg));</span><br><span class="line">            end = len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> substrings.toArray(<span class="keyword">new</span> String[substrings.size()]); <span class="comment">// list转数组方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p.s 我感觉splitByWholeSeparatorWorker和splitWorker的功能一样啊……</p><h4 id="ArrayUtils"><a href="#ArrayUtils" class="headerlink" title="ArrayUtils"></a>ArrayUtils</h4><ul><li>toString<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">final</span> Object array, <span class="keyword">final</span> String stringIfNull)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> stringIfNull;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>方法很简单，但是逻辑很有意思。每次都会创建一个<code>ToStringBuilder</code>，其数组元素的组合依赖<code>ToStringStyle</code>，包括字符串开头结尾和连接等，具体有很多。ToStringStyle也提供了一些常用组合的现成静态类。<code>append</code>方法最终会调用<code>ToStringStyle</code>的<code>ToStringStyle</code>方法，这里有个trick，为了防止数组循环调用appendInternal，<code>ToStringStyle</code>中维持了一个<code>ThreadLocal&lt;WeakHashMap&lt;Object, Object&gt;&gt;</code>。每次执行<br><code>ToStringStyle</code>前需要先检查是否注册了array对象，未注册需先注册，即往WeakHashMap中put。put的参数为arry和null。这个ThreadLocal被private static修饰，保证了ThreadLocal内存不会泄漏并使map存放多个线程的array。WeakHashMap则可以使退出调用的array可以被垃圾回收，因为value为null，所以保证了WeakHashMap也不会发生内存泄漏。事实上在方法调用完成后会主动调用unregister把map中的array给remove掉，因此我觉得可能这里weakhaspmap意义不大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;p&gt;常用的有commons-lang3 commons-io commons-collections，工具类并没有复杂的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基础复习！</title>
    <link href="http://lavaoxsea.com/2019/03/06/%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%EF%BC%81/"/>
    <id>http://lavaoxsea.com/2019/03/06/基础复习！/</id>
    <published>2019-03-06T08:24:21.000Z</published>
    <updated>2019-09-10T09:56:18.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><h4 id="进程线程协程"><a href="#进程线程协程" class="headerlink" title="进程线程协程"></a>进程线程协程</h4><ul><li>程序是一组指令的集合，它静态存储在磁盘</li><li>进程是程序运行的一个实例，进程是分配资源的基本单位</li><li>线程使操作系统进行任务调度的最小单元<ul><li>线程共享一个虚拟内存空间及其中资源</li></ul></li><li>协程是为非抢占式多任务产生子程序的计算机程序组件，协程允许不同入口点在不同位置暂停或开始执行程序<ul><li>协没有线程的上下文切换消耗。协程的调度切换是用户手动切换的,因此更加灵活,因此又叫用户空间线程.</li><li>原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li></ul></li></ul><p>一个进程由三部分组成：进程控制块PCB（Process Control Block），有关程序段，该程序段对其操作的数据结构集。<br>进程的PCB是系统感知进程的唯一实体。所以说到底，对进程进行操作，也可以理解为对PCB进行操作。 PCB是要常驻内存的。<br>系统把所有PCB组织在一起,并把他们放在内存的固定区域，构成PCB表。<br>可以通过链表队列或者索引表的方式组织就绪、阻塞、空闲的队列集合。</p><p>多进程：</p><ul><li>fork：会调用系统调用clone。父进程返回子进程ID，子进程返回0。</li><li>exec：是一系列函数。会将当前进程空间清除并装载可执行文件执行。</li><li>clone：指定位置开始执行，有选择的继承资源<br>多线程：</li><li>pthread</li></ul><p>fork时只会保留调用主进程中调用fork的线程，需要使用pthread_atfork()清理环境。慎用多进程多线程混合的模型。</p><h5 id="进程线程共享资源"><a href="#进程线程共享资源" class="headerlink" title="进程线程共享资源"></a>进程线程共享资源</h5><p><img src="threads-share.png" alt="线程共享"></p><p>进程拥有：</p><ul><li>数据段（存放全局变量）</li><li>代码段</li><li>打开文件描述符的集合</li><li>内核栈</li><li>其他进程空间</li><li>heap（从底向上）</li></ul><p>线程拥有自己的：</p><ul><li>stack（从顶向下）</li><li>程序计数器（指示运行在其程序中的位置）</li></ul><p>linux中进程和线程都视为task，因此进程可以共享地址空间（猜测由此实现线程）</p><p><strong>！进程和线程最本质的区别，在于隔离与共享上的不同。</strong><br>对于多进程来说，各个任务之间由操作系统保证了相互隔离。若要在多进程之间进行数据的传递、共享，必须要依赖操作系统信号、套接字、文件、管道等等。对于多线程来说，各个任务实际上处在同一进程空间，大多数的资源都能在内存空间中传递、共享，十分方便。但是另一方面，由于隔离不严，所以会出现十分棘手的「线程安全」问题。<br>进程间通信的开销较大，而线程安全的问题是可以解决的。</p><p>线程消息传递本质上是怎么样的(线程之间堆空间是共享的，所以在共享空间中放一个数据结构，大家都去访问这个结构)<br>进程之间传递的本质是什么呢(把进程A地址空间里的一段内存数据，借助操作系统的帮助，拷贝到进程B的地址空间中)</p><h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><h5 id="进程间通讯-线程间同步"><a href="#进程间通讯-线程间同步" class="headerlink" title="进程间通讯/线程间同步"></a>进程间通讯/线程间同步</h5><p>进程间通讯：</p><ol><li>管道（pipe）有名管道（FIFO）</li><li>信号（signal）</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>套接字（socket)</li></ol><p><a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">讲解</a></p><p>线程间同步：</p><ol><li>临界区（同一应用程序的线程间同步）</li><li>互斥量（mutex，为内核对象)</li><li>信号量</li><li>读写锁/共享互斥锁</li><li>条件变量</li><li>自旋锁</li><li>屏障（barrier）</li></ol><h4 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态/内核态"></a>用户态/内核态</h4><p>使进程从用户态切换到内核态的方式包括时钟中断、I/O 中断、系统调用和异常。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>分页就是人为地在逻辑上将连续的内存空间，按照固定大小切分成一段一段。对于虚拟空间（虚拟内存）来说，这样切分出来的固定大小叫做「页（Page）」；对于物理内存来说，这样切分出来的固定大小叫做「页帧（Page Frame）」。<br>每个进程都有自己的虚拟空间（切换进程的时候切换MMU的页表即可），这些虚拟空间可以映射到物理内存的不同或者相同的位置。<br>！虚拟空间的优点如下：</p><ul><li>允许虚拟内存大于物理内存</li><li>程序视角内存是连续的</li></ul><h5 id="进程虚拟地址和内核虚拟地址"><a href="#进程虚拟地址和内核虚拟地址" class="headerlink" title="进程虚拟地址和内核虚拟地址"></a>进程虚拟地址和内核虚拟地址</h5><p>内核空间虚拟地址是所有进程共享的，从效率角度看， 如果同样走四级页表翻译的流程，速度太慢；于是，内核在初始化时，就创建内核空间的映射（因为所有进程共享，有一份就够了），并且，采用的就是线性映射，而不是走页表翻译这种类似哈希表的方式。这样，内核地址的翻译，简化为一条偏移加减指令就行，相比走页表，效率大大提高。<br>在 Linux 刚引入的时候， i386 4G 的进程空间典型的是 3G user + 1G kernel 的划分。 那按线性方法， 1G 内核空间，只能映射 1G 物理地址空间，这对内核来说，太掣肘了。所以，折衷方案是， Linux 内核只对 1G 内核空间的前 896 MB 按前面所说的方法线性映射, 剩下的 128 MB 的内核空间， 采用动态映射[1]的方式，即按需映射的方式 ，这样，内核态的访问空间更多了。 这个直接映射的部分， 就是题主所说的 NORMAL 区， 就是所谓低端内存。到了 64 位时代， 内核空间大大增大， 这种限制就没了，内核空间可以完全进行线性映射，不过，基于[1]的缘故， 仍保留有动态映射这部分。</p><p>[1] 动态映射不全是为了内核空间可以访问更多的物理内存，还有一个重要原因： 当内核需要连续多页面的空间时，如果内核空间全线性映射，那么，可能会出现内核空间碎片化而满足不了这么多连续页面分配的需求。基于此，内核空间也必须有一部分是非线性映射，从而在这碎片化物理地址空间上，用页表构造连续虚拟地址空间,这就是所谓vmalloc空间。</p><h5 id="缺页错误-Page-Fault"><a href="#缺页错误-Page-Fault" class="headerlink" title="缺页错误 Page Fault"></a>缺页错误 Page Fault</h5><p>逻辑地址（虚拟地址）找不到物理地址对应的页帧，cpu报告缺页错误，用户进程因此中断（缺页中断）。进程由用户态切换到内核态，由内核Page Fault Handler处理缺页错误。</p><ul><li>Minor Page Fault: 若是此时物理内存里，已经有一个页帧正是此时 CPU 请求的内存页，那么这是一个软缺页错误；于是，Page Fault Hander 会指示 MMU 建立相应的页帧到页的映射关系。这一操作的实质是进程间共享内存——比如动态库（共享对象），比如 mmap 的文件。</li><li>Major Page Fault: 若是此时物理内存中，没有相应的页帧，那么这就是一个硬缺页错误；于是 Page Fault Hander 会指示 CPU，从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立这份页帧到页的映射关系。</li><li>Invalid Page Fault: 虚拟地址错误（比如非法地址）</li></ul><p>缺页错误的原因:<br>例如说，进程通过 mmap 系统调用，直接建立了磁盘文件和虚拟内存的映射关系。然而，在 mmap 调用之后，并不会立即从磁盘上读取这一文件。而是在实际需要文件内容时，通过 CPU 触发缺页错误，要求 Page Fault Handler 去将文件内容读入内存。<br>又例如说，一个进程启动了很久，但是长时间没有活动。若是计算机处在很高的内存压力下，则操作系统会将这一进程长期未使用的页帧内容，从物理内存转储到磁盘上。这个过程称为换出（swap out）。在 *nix 系统下，用于转储这部分内存内容的磁盘空间，称为交换空间；在 Windows 上，这部分磁盘空间，则被称为虚拟内存，对应磁盘上的文件则称为页面文件。在这个过程中，进程在内存中保存的任意内容，都可能被换出到交换空间：可以是数据内容，也可以是进程的代码段内容。</p><h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h5><p>已经提到很多回mmap，讲解一下mmap的全过程。首先进程的虚拟空间会和文件建立映射并得到虚拟空间的内存地址。在访问文件时，地址找不到页帧，进程缺页中断。Page  Fault Handler处理page fault，内存中不存在所需的页帧，因此是major page fault，通过懒加载将文件读到内存中（Page Cache），进程获取内存地址。加载文件时linux默认会read ahead（预读）32个page。之后进程再次读文件，需要再次处理page fault，但是因为预读到了Page Cache中，所以是minor page fault，handler会重新建立MMU内的映射关系。开启POSIX_MADV_RANDOM可以关闭预读来处理随机读的场景。</p><h5 id="IO-Page-Cache"><a href="#IO-Page-Cache" class="headerlink" title="IO/Page Cache"></a>IO/Page Cache</h5><p>所有正常的文件IO都是通过Page Cache完成的，在x86架构的linux，文件被认为是一系列的4kb的块。读取文件需要以4kb为单位，Page Cache拥有块的序号。<br>Sadly，内核还需要把Page Cache里的内容额外拷贝到用户态的缓冲区，也就是说内存会保存两份文件块，一份在Page Cache中，另一份在进程的缓存里。缺点是既费CPU时间又污染CPU缓存，还浪费物理内存。<br>mmap可以跳过用户缓存这一层，直接访问Page Cache内的文件块。</p><p>Page Cache是整个操作系统共享的资源，只要有足够的空闲内存，应该尽可能保留Page Cache，以提高缓存的命中率，减少和磁盘交互的开销。</p><p>Page Cache架构下的write()调用就只是将数据写入Page Cache再把它标记为dirty，而磁盘IO通常并不立即执行，程序也就无需为磁盘而阻塞。这样的不足就是机器一旦意外崩溃（断电），就可能会丢失部分数据。因此对完整性要求高的文件（比如数据库事务的log）通常会在写入后调用fsync()。<br>read()通常是阻塞等待数据就绪。为减少这里的阻塞，内核会一次性多读几个页，预先缓存起来，即“贪婪读取”(Eager Loading)。我们可以调整贪婪读取的参数(参见madvise(),readahead())，告诉内核我们读取起来是顺序还是随机。mmap也会预读。</p><p>跳过Page Cache也是可以的，数据库经常这样做。Linux设置O_DIRECT。用户进程的缓存会直接与磁盘交互。应用DIO通常是由于Page Cache是由操作系统控制，而这类应用比如数据库通常希望能够自己控制缓存。</p><p>文件映射可以设置为私有（只读）或者共享。动态库通过私有文件映射装入用户的程序空间。当有其他进程修改或者共享映射修改时采用copy-on-write机制。</p><h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h4><p><img src="io-model.png" alt=""><br><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">文章</a></p><h5 id="poll-select-epoll"><a href="#poll-select-epoll" class="headerlink" title="poll/select/epoll"></a>poll/select/epoll</h5><p>select:<br><code>int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code><br>监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。<br>select目前几乎在所有的平台上支持，但是有文件句柄的限制。</p><p>poll:<br><code>int poll (struct pollfd *fds, unsigned int nfds, int timeout);</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ol><li>将用户传入的pollfd数组拷贝到内核空间</li><li>查询每个文件描述符对应设备的状态，如果该设备尚未就绪，则在该设备的等待队列中加入一项并继续查询下一设备的状态。如果没有一个设<br>备就绪，这时则需要挂起当前进程等待，直到设备就绪或者超时。设备就绪后进程被通知继续运行，这时再次遍历所有设备，以查找就绪设备。</li><li>将获得的数据传送到用户空间并执行释放内存和剥离等待队列等善后工作</li></ol><p>epoll:<br>由三个系统调用组成 epoll_create/epoll_ctl/epoll_wait。epoll是做为一个虚拟文件系统来实现的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>sys_epoll_create: 主要是做一些准备工作，比如创建数据结构，初始化数据并最终返回一个文件描述符(表示新创建的虚拟epoll文件)，这个操作可以认为是一个固定时间的操作。</li><li>sys_epoll_ctl: 每次调用sys_epoll_ctl只处理一个文件描述符，通过op指定操作。op为EPOLL_CTL_ADD时，sys_epoll_ctl做一些安全性检查后进入ep_insert。ep_insert里将ep_poll_callback做为回掉函数加入设备的等待队列（假定这时设备尚未就绪）。ep_poll_callback在设备就绪后回调，将就绪设备加入就绪队列并唤醒epoll文件，从而避免每次检查就绪状态。</li><li>sys_epoll_wait：将进程自身加入等待队列，被唤醒后执行ep_events_transfer将结果拷贝到用户空间。参数events用来从内核得到事件的集合</li></ul><p>– 流程1 – </p><ol><li>用户进程调用epoll_create;</li><li>内核创建readyList,红黑树;</li><li>用户进程调用epoll_ctrl,传递监控的句柄(如Socket),以及在上面关注的事件;</li><li>内核将句柄插入红黑树;</li><li>内核的中断处理程序注册一个回调,如果红黑树中某个句柄的中断到了,<br>把它对应的事件放到ReadyList. </li></ol><p>— 流程2 — </p><ol><li>用户进程调用epoll_wait</li><li>内核从ReadyList返回可回调的事件.</li></ol><p><a href="https://titenwang.github.io/2017/10/05/implementation-of-epoll/" target="_blank" rel="noopener">https://titenwang.github.io/2017/10/05/implementation-of-epoll/</a><br><a href="http://www.hulkdev.com/posts/epoll-io" target="_blank" rel="noopener">http://www.hulkdev.com/posts/epoll-io</a><br>epoll为什么使用红黑树<br>因为epoll要求快速找到某个句柄,因此首先是一个Map接口。hash表需要应对百万连接时需要扩容，且空间利用率不高。</p><p>level triggered<br>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>edge triggered<br>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="零拷贝-cpu不参与内存复制任务"><a href="#零拷贝-cpu不参与内存复制任务" class="headerlink" title="零拷贝(cpu不参与内存复制任务)"></a>零拷贝(cpu不参与内存复制任务)</h4><p>FileChannel：transferTo方法。会先尝试调用transferToDirectly，其调用了sendfile系统调用，可以实现将页缓存在内核复制到socket的缓冲区。<br>Netty 的 Zero-copy:</p><ul><li>Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了各个 ByteBuf 之间的拷贝.</li><li>通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作.</li><li>ByteBuf 支持 slice 操作, 因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf, 避免了内存的拷贝.</li><li>通过 FileRegion 包装的FileChannel.tranferTo 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel, 避免了传统通过循环 write 方式导致的内存拷贝问题.</li></ul><h4 id="DIO"><a href="#DIO" class="headerlink" title="DIO"></a>DIO</h4><p>跳过操作系统的Page Cache，从而避免Page Cache换入换出的不确定行，可以自行控制缓存。<br>进行DIO的block size需要对齐，必须对齐为 blockSize 的整数倍。数据传输的开始点即文件和设备的偏移量，必须是blockSize的整数倍<br>open系统调用打开文件时传O_DIRECT，可以获取DIO模式下的文件句柄。使用posix_memalign系统调用分配缓存。</p><h4 id="缓存-LRU"><a href="#缓存-LRU" class="headerlink" title="缓存/LRU"></a>缓存/LRU</h4><p>LRU（Least recently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。<br>实现：实现LinkedHashMap的removeEldestEntry方法 / HashMap + deque(维护maxSize currentSize 两个值)<br><a href="https://blog.csdn.net/beiyeqingteng/article/details/7010411" target="_blank" rel="noopener">https://blog.csdn.net/beiyeqingteng/article/details/7010411</a></p><h4 id="Reactor-Proactor（IO设计模式）"><a href="#Reactor-Proactor（IO设计模式）" class="headerlink" title="Reactor/Proactor（IO设计模式）"></a>Reactor/Proactor（IO设计模式）</h4><p>Reactor模式采用同步IO，事件分离器负责等待文件描述符或socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。<br>Proactor采用异步IO。事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。<br><a href="https://segmentfault.com/a/1190000002715832" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002715832</a></p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><h4 id="awk-sed"><a href="#awk-sed" class="headerlink" title="awk/sed"></a>awk/sed</h4><h4 id="Linux-status"><a href="#Linux-status" class="headerlink" title="Linux status"></a>Linux status</h4><p><a href="http://www.bjhee.com/linux-status.html" target="_blank" rel="noopener">http://www.bjhee.com/linux-status.html</a></p><h4 id="如何后台执行程序"><a href="#如何后台执行程序" class="headerlink" title="如何后台执行程序"></a>如何后台执行程序</h4><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h4 id="网址输入"><a href="#网址输入" class="headerlink" title="网址输入"></a>网址输入</h4><ol><li>DNS<br>cache（内存）-&gt; 硬盘（hosts文件）-&gt; DNS服务器（UDP）<br>递归解析：LDNS（本地域名服务器）未命中-&gt;请求根域名服务器-&gt;一级一级查询子域(如.com)授权的DNS服务器-&gt;目标域名服务器查询自己的zone文件返回结果</li><li>IP<br>需要网关的MAC地址（ARP）</li><li>TCP三次握手</li><li>SSL握手</li><li>发送HTTP包</li><li>接受HTTP响应</li><li>TCP四次握手</li></ol><h4 id="OSI-七层"><a href="#OSI-七层" class="headerlink" title="OSI 七层"></a>OSI 七层</h4><p>物理 hub<br>数链 二层交换机 ARP RARP<br>网络 三层交换机 路由器 IP ICMP<br>传输 TCP UDP<br>(会话 表示)<br>应用 HTTP Telnet FTP</p><p>ping命令所使用的协议是什么（ICMP），简述其过程<br>包装在IP数据包内，发起请求后先广播ARP寻找目标IP的MAC地址，之后发送数据。目标服务器收到请求后，根据请求中的原MAC地址进行相应。</p><p>NAT 网络地址转换协议(通过多端口实现，维护映射表)</p><p>DHCP TCP/IP协议在初始化时，会自动调用DHCP模块，DHCP通过广播的方式去发现（Discover）DHCP服务器，获得IP参数，IP地址、网络掩码、默认网关、DNS服务器，TCP/IP所有模块完成初始化</p><h4 id="网络层的路由算法"><a href="#网络层的路由算法" class="headerlink" title="网络层的路由算法"></a>网络层的路由算法</h4><p>路由算法分为：非自适应性（静态路由）与自适应性（动态路由）<br>静态路由算法—-Dijkstra算法（衡量路径长度的方法是跳数）；扩散算法flooding。<br>动态路由：<br>距离-矢量路由协议 (RIP/IGRP)<br>这类协议使用贝尔曼-福特算法（Bellman-Ford）计算路径。在距离-矢量路由协议中，每个路由器并不了解整个网络的拓扑信息。它们只是向其它路由器通告自己的距离、也从其它路由器那里收到类似的通告。每个路由器都通过这种路由通告来传播它的路由表。在之后的通告周期中，各路由器通告其整张路由表。该过程持续至所有路由器的路由表都收敛至一稳定状态为止。<br>链路状态路由协议 (OSPF)<br>在链路状态路由协议中，每个节点都知晓整个网络的拓扑信息。各节点使用自己了解的网络拓扑情况来各自独立地对网络中每个可能的目的地址计算出其最佳的转发地址（下一跳）。所有最佳转发地址汇集到一起构成该节点的完整路由表。与距离-矢量路由协议使用的那种每个节点与其相邻节点分享自己的路由表的工作方式不同，链路状态路由协议的工作方式是节点间仅传播用于构造网络连通图所需的信息。<br>最初创建这类协议就是为了解决距离-矢量路由协议收敛缓慢的缺点，然而，为此链路状态路由协议会消耗大量的内存与处理器能力。<br><a href="https://blog.csdn.net/qq1170836331/article/details/53287719" target="_blank" rel="noopener">https://blog.csdn.net/qq1170836331/article/details/53287719</a></p><h4 id="ARP-RARP（数据链路层）"><a href="#ARP-RARP（数据链路层）" class="headerlink" title="ARP/RARP（数据链路层）"></a>ARP/RARP（数据链路层）</h4><p>ARP（Address Resolution Protocol，地址解析协议）是将IP地址解析为以太网MAC地址（物理地址）的协议。<br>无论是主机，还是交换机都会有一个用来缓存同一网段设备IP地址和MAC地址的ARP映射表<br><a href="https://blog.csdn.net/wenqian1991/article/details/44133039" target="_blank" rel="noopener">https://blog.csdn.net/wenqian1991/article/details/44133039</a><br>ARP协议过程: 广播</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">CoolShell</a><br>什么叫连接：</p><p>TCP 使用校验和，确认和重传机制来保证可靠传输<br>TCP 使用滑动窗口机制来实现流量控制。TCP是全双工的，即两端皆维护一个发送缓冲区和接收缓冲区。<br>TCP 拥赛控制：</p><ul><li>慢启动：指数增加发送包数量，到达慢启动窗口阈值时拥塞避免</li><li>拥塞避免：线性增加发送包的数量（增加倒数）<br>这两个阶段出现超时则会将发送包的数量重设为1，并将拥塞窗口的阈值变为一半</li><li>快速重传：接收方收到失序报文后进行发送重复确认，发送方收到三个重复确认后认为超时</li><li>快速恢复：快速重传发现超时后不再慢启动，即把数量设为1，而是设为拥塞窗口大小（拥塞窗口减半），之后线性增加。</li></ul><p>三次握手：<br>第一次握手(SYN=1, seq=x)<br>C: CLOSED -&gt; SYN_SENT      S: LISTEN -&gt; SYN_RECEIVED<br>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)<br>C: SYN_SENT -&gt; ESTAB<br>第三次握手(ACK=1，ACKnum=y+1)<br>S: SYN_RECEIVED -&gt; ESTAB</p><p>四次握手：<br>第一次🤝(FIN=1，seq=x)<br>C: ESTA -&gt; FIN_WAIT_1      S: ESTA -&gt; CLOSE_WAIT<br>第二次🤝(ACK=1，ACKnum=x+1)<br>C: FIN_WAIT_1 -&gt; FIN_WAIT_2<br>第三次🤝(FIN=1，seq=y)<br>S: CLOSE_WAIT -&gt; LAST_ACK C: FIN_WAIT_2 -&gt; TIME_CLOSE<br>第四次🤝(ACK=1，ACKnum=y+1)<br>S: LAST_ACK -&gt; CLOSED      C: TIME_WAIT -&gt; CLOSED</p><p>全联接/半连接队列：<a href="http://jm.taobao.org/2017/05/25/525-1/" target="_blank" rel="noopener">http://jm.taobao.org/2017/05/25/525-1/</a></p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>udp如何实现不乱序</p><p>udp如何实现不丢包</p><p>想要tcp的功能，又想要用udp的速度怎么做 </p><p>无连接。可广播。</p><h4 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h4><p>影响因素：</p><ul><li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ul><p>1.0 -&gt; 1.1</p><ol><li>缓存处理: 1.0:If-Modified-Since,Expires 1.1:Entity tag，If-Unmodified-Since, If-Match, If-None-Match</li><li>带宽优化: HTTP1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206</li><li>HTTP1.1的请求消息和响应消息都应支持Host头域</li><li>长连接</li></ol><p>1.1 -&gt; 2.0</p><ol><li>协议解析由文本变为二进制</li><li>多路复用：多个request共用一个连接，通过id号区分，请求有优先级防止阻塞</li><li>header压缩</li><li>服务器推送</li></ol><p>HTTP2.0的多路复用和HTTP1.X中的长连接复用区别：<br>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会。<br>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。</p><p>当保持长连接时，浏览器如何判断一次请求已经完成：<br>Content-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。<br>当服务端无法知道实体内容的长度时，就可以通过指定 Transfer-Encoding: chunked 来告知浏览器当前的编码是将数据分成一块一块传递的。当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。</p><p>服务端设置Keep-Alive timeout：防止客户端一直不主动关闭连接。</p><p>HTTP状态码:<br>100 信息 200 成功 300 重定向 400 客户端错误 500 服务端错误<br>204: 请求被成功处理，但响应的主体部分为空。适用于只需要客户端向服务端发送数据的情况<br>206: 客户端进行了部分请求，服务端返回指定部分的内容<br>301: 请求的资源已被分配了新的URL，永久性重定向<br>302: 请求的资源已被分配了新的URL，暂时性重定向<br>304: 客户端进行附带条件的请求时，服务端允许访问资源，但没满足条件。304跟重定向没有任何关系。<br>401: 请求报文中存在语法错误<br>402: 发送的请求需要HTTP认证<br>403: 请求的资源被服务器拒绝<br>404: 服务器上没有请求的资源<br>503: 服务器正处于超负荷或维护状态，无法处理请求</p><p>HTTP方法：<br>GET POST PUT HEAD DELETE OPTIONS<br>幂等：<br>同样的请求被执行一次与连续执行多次的效果是一样的。幂等方法不应该具有副作用。GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。<br>GET和POST的区别：<br>GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的，GET方法的报文主体没有任何语义。<br>POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存。</p><p>HTTP如何实现状态化：<br>服务器相应携带set-cookies首部，设置客户端内容。客户端发送时携带cookie首部。cookie被禁用了，URL重写</p><h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><p>一个session的建立是从一个用户向服务器发第一个请求开始，而以用户显式结束或session超时为结束。<br>每一个session又一个标示号，服务器用来辨别用户。有两种方式实现：cookies和URL重写</p><h4 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h4><p>HTTPS = HTTP + 加密 + 数字签名 + 认证<br>对称加密：加密和解密都是使用的同一个密钥。DES、AES-GCM、ChaCha20-Poly1305<br>非对称：公钥和算法都是公开的，私钥是保密的。RSA、DSA、ECDSA、 DH、ECDHE<br>哈希算法：将任意长度的信息转换为较短的固定长度的值，不可逆。MD5、SHA-1、SHA-2、SHA-256 </p><p>数字证书：由CA使用私钥加密生成，包含证书所有人的名称、公钥、数字签名。<br>数字签名：在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。然后再用CA的私钥加密，就得到了数字签名，附在以上证书的末尾，一起传输给客户端。</p><p>SSL/TSL的四次握手：<br>Client端向Server端的443端口发出请求，带上随机数client_random和支持的加密方式列表<br>Server端返回随机数server_random ，选择的加密方式和服务器证书链<br>Client端验证这个证书是否合法，如果非法则提示用户是否“继续接受这个不可信的网站”，如果合法则使用证书中的公钥加密premaster secret发送给服务端<br>Server端使用私钥解密premaster secret，然后通过client_random，server_random 和premaster secret 生成master secret，用于对称加密后续通信内容。进而推导出session key、HMAC key。Session Key用于加密/解密数据， HMAC Key主要用于保护数据的完整性。<br>Sever端用master secret加密最终需要返回的网站内容<br>Client端也用相同的方式生成这个master secret解密收到的消息</p><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>bind listen accept 操作系统做了什么？ </p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><h2 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。<br>ACID actomicity consistance isolation durability<br>持久性：如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。<br>它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。<br>而第二层意思其实是指逻辑上的对于开发者的要求，我们要在代码中写出正确的事务逻辑，比如银行转账，事务中的逻辑不可能只扣钱或者只加钱，这是应用层面上对于数据库一致性的要求。</p><p>Active：事务的初始状态，表示事务正在执行<br>Partially Commited：在最后一条语句执行之后<br>Failed：发现事务无法正常执行之后<br>Aborted：事务被回滚并且数据库恢复到了事务进行之前的状态之后<br>Commited：成功执行整个事务</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>事务日志: 包含了事务的 ID、修改的行元素以及修改前后的值<br>undo-log:用于回滚。copy事务前的行到undo buffer，buffer满后刷盘。磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间）。<br>redo-log:用于确保数据持久化到磁盘。保存执行的SQL语句到一个指定的Log文件，当Mysql执行recovery时重新执行redo log记录的SQL操作。redo log会被首先写入log buffer，事务提交后会刷盘。在磁盘上作为一个独立的文件存在，即Innodb的log文件。</p><p>Binary Log 二进制日志: 1.实现恢复 2.实现mysql到其他数据源（如ElasticSearch)的数据复制<br>Error Log 错误日志: 记录出错信息<br>Slow Query Log 慢查询日志: 记录执行时间超过阈值的SQL语句<br>Genaral Query Log 查询日志: 记录所有SQL</p><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>1NF: 属性不可分<br>2NF: 不存在非主属性对码的部分依赖<br>3NF: 不存在非主属性对码的传递依赖<br>BCNF: 不存在任何属性对码的传递依赖<br>码：并不是主键，而是可以区分元组的属性集合。</p><h4 id="mysql引擎"><a href="#mysql引擎" class="headerlink" title="mysql引擎"></a>mysql引擎</h4><p>myisam:<br>支持全文索引，查询效率高<br>数据单独存一个文件，统计行数容易<br>不强制要求主键<br>只有表锁</p><p>innodb<br>5.6之后也支持全文索引<br>支持事务<br>支持外键<br>聚簇索引，数据和索引存一起<br>必须有主键<br>支持行锁和表锁</p><h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><h4 id="nosql"><a href="#nosql" class="headerlink" title="nosql"></a>nosql</h4><h4 id="连接join"><a href="#连接join" class="headerlink" title="连接join"></a>连接join</h4><p>内连接<br>左外连接<br>右外连接<br>全外连接</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>B树/B+树：mysql使用B+树做索引。<br>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>优势：</p><ul><li>B+tree的磁盘读写代价更低，因为其节点不包含关键字所以节点占用空间更小。复杂度中d越大索引的性能越好，而出度的上限取决于节点内key和data的大小。</li><li>查询效率稳定，都需要找到叶节点</li><li>范围查询有优势</li><li>B+树拥有一个含有所有关键字的列表，因此关键字两两相连，在同一个块内符合存储逻辑。</li></ul><p>mongo使用B树做索引。MongoDB 是聚合型数据库，而 B树恰好 key 和 data 域聚合在一起。</p><p>MyISAM: 使用非聚簇索引，主索引和其他索引没有区别，都是保存了数据地址，主索引要求唯一。索引文件和数据文件分离。<br>InnoDB: 使用聚簇索引，叶节点保存完整的数据记录。InnoDB的辅助索引data域存储相应记录主键的值而不是地址。聚簇索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。辅助索引也存储了索引列数据。<br>不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p>聚簇优点：可以把相关数据保存在一起。减少IO次数，而非聚簇可能需要多次IO。数据和索引保存在一起访问更快。<br><a href="https://www.cnblogs.com/songwenjie/p/9402295.html" target="_blank" rel="noopener">https://www.cnblogs.com/songwenjie/p/9402295.html</a><br><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><h5 id="sql优化技巧"><a href="#sql优化技巧" class="headerlink" title="sql优化技巧"></a>sql优化技巧</h5><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h6 id="锁兼容"><a href="#锁兼容" class="headerlink" title="锁兼容"></a>锁兼容</h6><p>共享锁(Share)读锁/S锁：若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其它事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。<br>排它锁(Exclusive)写锁/X锁：若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其它事务在T释放A上的锁之前不能再读取和修改A。<br>更新锁(Update)：防止两个持有S锁的事务同时尝试获取X锁导致死锁，只允许获取U锁的事务获取X锁。</p><h6 id="加锁算法"><a href="#加锁算法" class="headerlink" title="加锁算法"></a>加锁算法</h6><p>Record Locks 记录锁 innodb一定存在聚簇索引，因此行锁最终都会落到聚簇索引上。<br>Gap Locks 间隙锁 对一个开区间范围加锁，用于Repeatable Read和Serializable级别<br>Next-Key Locks 临建锁 组合了记录锁和间隙锁，是一个左开右闭区间</p><h6 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h6><p>悲观锁：悲观锁需使用数据库的锁机制实现，如使用行级排他锁或表级排它锁。 select …for update 对所选择的数据进行加锁处理<br>乐观锁：乐观锁使用由程序逻辑控制的技术来避免可能出现的并发问题。乐观锁不能解决脏读的问题。</p><h6 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h6><p>意向共享锁(IS锁):一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。<br>意向排他锁(IX锁):一个事务在获取（任何一行/或者全表）X锁之前，一定会先在所在的表上加IX锁。<br>插入意向锁: 插入意向锁是间隙锁的一种，针对insert操作产生。在RR级别下启用，应对间隙锁导致的插入性能低。可以使锁定区间相同但行记录不冲突的数据并发插入。</p><h6 id="活锁-死锁"><a href="#活锁-死锁" class="headerlink" title="活锁/死锁"></a>活锁/死锁</h6><p>活锁；申请的资源一直被其他事务抢占。使用先来先服务来解决。<br>预防死锁：<br>一次封锁法。缺点：扩大了锁的范围。<br>顺序封锁法。缺点：维护顺序很难。事务是动态的很难按顺序执行。<br>诊断死锁：1.等待时间超时则认为死锁。2.等待图法。<br>处理死锁：选择一个处理死锁代价最小的事务将其撤销，放弃其持有的锁并撤销修改。</p><h6 id="调度两段锁协议"><a href="#调度两段锁协议" class="headerlink" title="调度两段锁协议:"></a>调度两段锁协议:</h6><p>目的是使事务调度可串行化。可串行性定义：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为可串行化调度。<br>指所有的事务必须分两个阶段对数据项加锁和解锁。即事务分两个阶段，第一个阶段是获得封锁。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是释放封锁，事务可以释放任何数据项上的任何类型的锁，但不能申请。<br>第一阶段是获得封锁的阶段，称为扩展阶段：其实也就是该阶段可以进入加锁操作，在对任何数据进行读操作之前要申请获得S锁，在进行写操作之前要申请并获得X锁，加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。就是加锁后就不能解锁了。<br>第二阶段是释放封锁的阶段，称为收缩阶段：当事务释放一个封锁后，只能进行解锁而不能再进行加锁操作。</p><h6 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC:"></a>MVCC:</h6><p>可以认为是行级锁的一个变种，但是它在很多情况下都避免了加锁操作，因此开销更低。实现了非堵塞的读操作，写操作也只需要锁定必要的行。<br>innodb每个数据行都包含三个隐藏字段：ID(隐藏ID) DB_TRX_ID(事务ID) ROLL_BACK_PTR(回滚指针)<br>ID: 6字节 在没有指定主键且不存在唯一非NULL列的情况下用作聚簇索引的列<br>DB_TRX_ID: 6字节 递增，标识事务版本号<br>ROLL_BACK_PTR: 7字节 指向undolog中改行的历史记录<br>MVCC使用undo-log实现:<br><img src="undolog.jpg" alt="undolog"><br>read-view: 创建一个新事务的时候，InnoDB会将当前系统中的活跃事务列表（trx_sys-&gt;trx_list）创建一个副本（read view），保存系统当前不应该被本事务看到的其他事务id列表。当用户在这个事务中要读取该行记录的时候，InnoDB会将该行当前的版本号与该read view进行比较。若小于活跃事务列表中的最小事务id或者等于当前事务id，则取值，否则通过undo-log查询历史版本直到小于，并取值。<br>Read Committed仍会出现不可重复读的原因是read view在每次读之前生成而不是事务执行前生成。</p><h6 id="当前读-快照读"><a href="#当前读-快照读" class="headerlink" title="当前读/快照读"></a>当前读/快照读</h6><p>当前读：读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></p><p>快照读：不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现</p><h5 id="事务隔离级别-封锁协议"><a href="#事务隔离级别-封锁协议" class="headerlink" title="事务隔离级别/封锁协议"></a>事务隔离级别/封锁协议</h5><p>事务隔离级别和封锁协议并不严格对应<br>问题：第一类更新丢失 第二类更新丢失 脏读 不可重复读 幻读<br>Read Uncommitted：第二类更新丢失 脏读 不可重复读 幻读<br>一级封锁协议：写加X锁  可解决丢失更新</p><p>Read Committed：第二类更新丢失 不可重复读 幻读<br>二级封锁协议：写加X锁，读加临时S锁  可解决丢失更新<br>innodb实现：未加S锁，而是通过MVCC（多版本并发控制）实现。</p><p>Repeatable Read：幻读<br>三级封锁协议：写加X锁，读加S锁<br>innodb也是通过MVCC(事务开始时创建read-view)解决不可重复读，但是仍然有可能出现幻读。因为存在当前读。所以需要通过临建锁解决。</p><p>Serailziable<br>使用表级锁</p><hr><p>MsSQL的锁是加在唯一索引上的。<br>RU/RC: 不存在Gap Lock，<strong>条件列</strong>是唯一索引则直接加在索引上，若是普通索引则找到相应行的聚簇索引(主键)加锁。若不是索引则会先对所有行加锁，再把不符合再把锁去掉。<br>RR/Serailziable: <strong>条件列</strong>是唯一索引则精准查询(=)加Record Lock，范围查询(&gt;,&lt;)加Record Lock及Gap Lock，若是非唯一索引则无论精准还是范围查询都会加Record Lock及Gap Lock。若不是索引则对每一条记录加Record Lock并对所有区间都加Gap Lock。</p><p>对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p><p><a href="https://mp.weixin.qq.com/s/ODbju9fjB5QFEN8IIYp__A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ODbju9fjB5QFEN8IIYp__A</a></p><h4 id="MySQL主备模式"><a href="#MySQL主备模式" class="headerlink" title="MySQL主备模式"></a>MySQL主备模式</h4><h5 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h5><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h5 id="AbstractQueuedSynchronizer-队列同步器AQS"><a href="#AbstractQueuedSynchronizer-队列同步器AQS" class="headerlink" title="AbstractQueuedSynchronizer(队列同步器AQS)"></a>AbstractQueuedSynchronizer(队列同步器AQS)</h5><p>实现AbstractOwnableSynchronizer接口，子类为Sync、NonfairSync及FairSync。Sync作为ReentrantLock的内部类实现，好处是可以控制独占模式和共享模式使用同一套组件，区别只在加锁的逻辑。<br>volatile修饰int型的state表示同步状态(0未被锁，1被锁)，通过内置的FIFO双向链表来完成资源获取线程的排队工作。<br>head和tail分别是AQS中的Node变量，其中head指向同步队列的头部，注意head为空结点，不存储信息(节点记录等待线程的信息)。而tail则是同步队列的队尾，同步队列采用的是双向链表的结构这样可方便队列进行结点增删操作。多个线程都通过【CAS+死循环】这个free-lock黄金搭档来对队列进行修改。<br>Node拥有 waitStatus等待状态,存在4种，初始化为0</p><ul><li>CANCELLED(1) 被取消，等待移除</li><li>SIGNAL(-1) 处于唤醒状态，等待pre节点释放锁</li><li>CONDITION(-2) 处于同步队列，被唤醒后进入同步队列等待锁</li><li>PROPAGATE(-3) 共享模式中，该状态表示可运行<br>入队后节点检查能否获取锁，若prev节点的waitStatus已经是SIGNAL，则这个时候线程会被通过LockSupport挂起。<br>AQS的FIFO的等待队列给解决在锁竞争方面的羊群效应问题提供了一个思路：保持一个FIFO队列，队列每个节点只关心其前一个节点的状态，线程唤醒也只唤醒队头等待线程。</li></ul><h5 id="interrupt-isInterrupted-interrupted"><a href="#interrupt-isInterrupted-interrupted" class="headerlink" title="interrupt isInterrupted interrupted"></a>interrupt isInterrupted interrupted</h5><p>interrupt：设置中断线程状态，如果线程阻塞则抛出InterruptedException<br>isInterrupted：返回中断状态<br>interrupted：返回中断状态并重置</p><h5 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h5><p>ThreadGroup方便线程的管理，可以设置daemon、优先级、异常处理器等，方便管理组内线程。创建线程时不指定组则默认使用创建线程的组。<br>异常处理器的意义在于可以处理不是由我们创建的线程。</p><p>每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个进程中线程组是以树形的方式存在，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。</p><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>Executors是工厂类，返回<code>ThreadPoolExecutor</code>的实例，也就是线程池。<br><code>ThreadPoolExecutor</code>参数：</p><ul><li>corePoolSize<br>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li><li>maximumPoolSize<br>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</li><li>keepAliveTime<br>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用</li><li>workQueue<br>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口。JDK中提供的：ArrayBlockingQueue、LinkedBlockingQuene、SynchronousQuene（只能保留以一个元素，阻塞插入） PriorityBlockingQuene。</li><li><code>ThreadFactory</code> 创建线程的工厂</li><li>handler 线程池的饱和策略（队列满了且没有空闲线程）默认抛出异常。</li></ul><p>线程池内部状态：<br><img src="thread-pool-status.jpg" alt="thread-pool"><br>shutdown 不添加新任务但是继续执行队列内任务<br>stop 中断现在执行任务的线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></p><p> ctl的低29位为线程数，高3位为状态。ctlOf函数就是取或，RUNNING为高三位为101，其余29位为0（-1 &lt;&lt; 29)。其他状态类似。</p><p>任务执行：<br>execute-&gt;addWorker-&gt;new Worker(task, thread_t)-&gt;workers.add(worker)-&gt;thread_t.start()-&gt;task=getTask()-&gt;task.run()</p><p><img src="thread-pool-process.png" alt="thread-pool-process"></p><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><p>ThreadLocal提供了set和get访问器用来访问与当前线程相关联的线程局部变量。<br>get从当前线程的threadlocalmap中取出当前线程对应的变量的副本【注意，变量是保存在线程中的，而不是保存在ThreadLocal变量中】。<br>每个线程都有一个这样的threadLocals引用的ThreadLocalMap，以ThreadLocal和ThreadLocal对象声明的变量类型作为参数。这样，我们所使用的ThreadLocal变量的实际数据，通过get函数取值的时候，就是通过取出Thread中threadLocals引用的map，然后从这个map中根据当前threadLocal作为参数，取出数据。<br>【Threadlocal类似于一个数据访问的接口】<br>ThreadLocalMap在ThreadLocal调用createMap初始化，set时把threadlocal&lt;?&gt;作为键，计算hash，放到Entry数组的相应位置。如果冲突则使用线性探测法（不超过最大值则加一），hashmap使用了链表法。<br>Entry继承了WeakReference，键为WeakReference，值不是。避免ThreadLocal对象在没有强引用时的内存泄漏。可能存在键释放值还存在的问题，因此在使用完ThreadLocal后应该调用remove方法。</p><h5 id="HashMap-HashTable-ConcurrentHashMap"><a href="#HashMap-HashTable-ConcurrentHashMap" class="headerlink" title="HashMap/HashTable/ConcurrentHashMap"></a>HashMap/HashTable/ConcurrentHashMap</h5><p>hashcode：对象的内存地址计算出的int值<br>hash：hashcode的高16位异或低16位，对table length取模 -&gt; hash &amp; (len - 1)<br>HashTable == Collections.synchronized(HashMap) hashtable用的是this锁，synchronizedmap可以传入一个锁</p><p>HashMap<br>内部数据结构：数组 + 链表/红黑树（ Node&lt;K,V&gt; ）<br>负载因子：默认0.75，当node数目达到阈值的0.75时，扩容为2倍，初始容量为16</p><p>fast-fail: 通过检查modCount域实现。对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等。</p><p>put： 查看数组长度，为0扩容。 -&gt; hash到对应位置，不存在插入新Node。 -&gt; 检查hash到的节点，如果key一样，取出旧节点。 -&gt; 如果hash出的节点是TreeNode则调用putTreeVal，存在也会返回旧节点。 -&gt; 遍历链表，找到key一样的则取出旧节点。如果没有找到且长度为8-1，变为红黑树。 -&gt; 判断旧节点是否存在，存在返回其值，不存在将entry数加一，并判断是否需要扩容。</p><p>resize：先计算新的cap和thre并创建新数组 -&gt; 遍历数组，取出每个Node，如果没有Next，直接在新的数组中计算hash并放入相应的位置。 -&gt; 如果是TreeNode则进行分解。 -&gt; 如果是链表，则建立两个Node（一个代表相同hash一个代表不同hash，因为resize为2倍，所以hash旧节点只会多一位新出现两种可能）。分别计算旧链表中每个hash值，判断是否与新的hash相同，并加到相应的Node后。结束后把两个Node加到数组里。</p><p>HashMap与TreeMap<br>TreeMap基于红黑树实现，HashMap则是哈希表(数组+链表+红黑树)</p><p>ConcurrentHashMap<br>1.7 使用Segment作分段锁，每个segment持有一个table，ConcurrentHashMap拥有一个Segment数组。默认并发级别创建16个Segment<br>1.8 实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层采用数组+链表+红黑树的存储结构。</p><p>持有一个sizeCtl ：默认为0，用来控制table的初始化和扩容操作。-1代表正在初始化，如果table初始化完成，表示table的容量。ConcurrentHashMap直到put才会加载，sizeCtl可以控制线程同步（CAS）。</p><p>扩容实现机制:<br>扩容期间，将table数组中的元素 迁移到 nextTable<br>多线程之间，以volatile的方式读取sizeCtl属性，来判断ConcurrentHashMap当前所处的状态。通过cas设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。</p><ul><li>sizeCtl=0：表示没有指定初始容量。</li><li>sizeCtl&gt;0：表示初始容量。</li><li>sizeCtl=-1,标记作用，告知其他线程，正在初始化</li><li>sizeCtl=0.75n ,扩容阈值</li><li>sizeCtl &lt; 0 : 表示有其他线程正在执行扩容<br>(太难了下次看……)[<a href="https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/]" target="_blank" rel="noopener">https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/]</a><br>扩容时在添加新节点也会加锁</li></ul><p>put：表不存在则初始化 —&gt; 节点不存在则CAS添加 -&gt; 否则取出节点，判断是否在扩容，则一起进行扩容操作。 -&gt; 否则对节点加锁，再次判断是否需要扩容，遍历链表，找到修改，找不到添加 -&gt; 如果是红黑树节点，putTreeVal -&gt; 长度超过8变成红黑树。</p><p>get: 不加锁。</p><h5 id="fork-join"><a href="#fork-join" class="headerlink" title="fork/join"></a>fork/join</h5><p>一组工作者线程池是准备好的。每个工作线程都是标准的（『重量级』）处理存放在队列中任务的线程（这地方指的是Thread类的子类FJTaskRunner的实例对象）。通常情况下，工作线程应该与系统的处理器数量一致。<br>所有的Fork/Join任务都是轻量级执行类的实例，而不是线程实例。在FJTask框架中，这些任务将作为子类继承FJTask，实现了Runnable接口。通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，</p><ul><li>RecursiveAction：用于没有返回结果的任务。</li><li>RecursiveTask ：用于有返回结果的任务。<br>一个简单的控制和管理类（这里指的是FJTaskRunnerGroup）来启动工作线程池</li></ul><p>实现：每个工作线程持有一个双端队列，任务后进先出，自己的队列为空时会从别的工作线程队列头获取任务<br><a href="http://ifeve.com/java-fork-join-framework/" target="_blank" rel="noopener">http://ifeve.com/java-fork-join-framework/</a></p><p>Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的处理器数量。</p><h5 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h5><p>使用ReentrantLock和两个Condition(notEmpty/notFull)实现，默认非公平。poll和remove加锁。<br>ArrayBlockingQueue 内部只有一个ReentrantLock<br>LinkedBlockingQueue 内部有两个ReentrantLock，吞吐量高于ArrayBlockingQueue</p><h5 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h5><p>就绪 阻塞 运行 （新建/终止）<br>Runnable 对应运行/就绪<br>Blocked 对应阻塞（等待锁）<br>Waiting 对应阻塞（等待唤醒）<br>Timed_waiting 对应阻塞（等待唤醒或超时）</p><h4 id="jmh"><a href="#jmh" class="headerlink" title="jmh"></a>jmh</h4><h4 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h4><h5 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h5><h5 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h5><h5 id="beaan的生存范围"><a href="#beaan的生存范围" class="headerlink" title="beaan的生存范围"></a>beaan的生存范围</h5><h5 id="IOC容器生命周期"><a href="#IOC容器生命周期" class="headerlink" title="IOC容器生命周期"></a>IOC容器生命周期</h5><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><h5 id="运行时数据区域："><a href="#运行时数据区域：" class="headerlink" title="运行时数据区域："></a>运行时数据区域：</h5><ol><li>程序计数器Program Counter Register<br>线程私有，记录虚拟机字节码指令执行地址 Native方法为空</li><li>虚拟机栈VM Stack<br>线程私有，方法执行创建帧栈，包括 局部变量表(基本类型+对象引用reference类型)、操作数栈、方法出入口<br>栈深度超过最大深度导致StackOverflowError 无法申请到足够内存OOM</li><li>本地方法栈Native Method Stack<br>与VM Stack相似，为Native方法服务</li><li>Java 堆<br>线程共享，存放对象实例 新声代(Eden/From Survivor/To Survivor)+老年代 分配对象时无法扩展导致OOM</li><li>方法区<br>线程共享，存储类信息、常量、静态变量 运行时常量池(存放编译期生成的字面量和符号引用，运行时常量) 无法申请到内存OOM</li><li>直接内存<br>与JVM无关 当物理内存不够分配OOM</li></ol><h5 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h5><ol><li>常量池中寻找类的符号引用，类加载</li><li>分配内存：指针碰撞/空闲列表 选择哪种由堆是否规整决定 Serial/ParNew等带Compact过程的收集器使用Bump the Pointer，CMS这种使用Mark-Sweep的使用Free List。 并发分配内存有两种方式：1.CAS+失败重试 2.按线程划分在不同的空间中进行，每个线程在堆中分配一小块内存，称为本地线程分配缓冲Thread Local Allocation Buffer, TLAB。TLAB用完分配新的TLAB。可以用过-XX:UseTLAB设定。</li><li>内存初始化为0，设置对象头</li><li>执行init方法初始化: 超类的&lt;init&gt;()方法调用 实现对任何实例变量的初始化 构造方法体的代码</li></ol><h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>对象头(Header) + 实例数据(Instance Data) + 对齐填充(Padding)<br>对象头有两部分Mark Word和类型指针 对象起始位置必须是8字节整数倍</p><h5 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h5><p>标记-清除(Mark-Sweep) 标记基于可达性分析。问题：1.标记和清除效率都不高 2.可能产生大量的内存碎片<br>复制(Copying) 内存需要分为两块<br>标记整理(Mark-Compact)<br>分代收集算法：分为年轻代和老年代，年轻代使用Copying，老年代使用标记-清理或标记整理</p><h5 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h5><p>新生代：（都为复制算法）<br>Serial: stop the world 单线程<br>ParNew: 多线程版Serial<br>Parallel Scavenge: 吞吐量优先<br>老年代：<br>Serial Old: 标记整理，可以配合Parallel Scavenge使用，CMS在Current Mode Failure时使用<br>Parallel Old: 多线程版，可以配合Parallel Scavenge，适合注重吞吐量及CPU资源敏感<br>CMS(Concurrent Mark Sweep): 目标最短回收停顿时间，包含4步：初始标记、并发标记、重新标记、并发清除。1、3步需要STW，第二步垃圾回收线程和用户线程一起运行，会产生浮动垃圾，当剩余空间不足以分配时就会产生Current Mode Failure。比较耗CPU资源。使用标记清除，会产生大量碎片，可以通过参数设置Compact。</p><p>GC日志中：GC和Full GC区别在有没有STW，而不是新声代老年代。根据不同的垃圾收集器，日志中会有相应的代名，如DefNew、ParNew、Tenured等</p><h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><p>先将对象分配在新生代的Eden区，空间不足则Minor GC。如果GC期间发现已有对象无法全部放到Survivor空间，需要通过分配担保机制将它们转移到老年代中，整体也视为一次Minor GC。</p><p>大对象直接进入老年代，通过-XX:PretenuredSizeThreshold设置阈值。</p><p>长期存活的对象将进入老年代。通过-XX:MaxTenuringThreshold设置，默认15</p><p>动态对象年龄判定。当Survivor中年龄一样的对象占空间的一半时，大于等于该年龄的对象将进入老年代。</p><p>空间分配担保。Minor GC之前会判读老年代最大可用连续空间是否大于新生代所有对象总和，如果小于则查看是否允许担保失败，如果允许则比较剩余大小和历代晋升至老年代对象平均大小，如果大于则尝试Minor GC。否则进行一次Major GC。</p><p>元空间：PermGem(永久代)被移除，字符串常量被移到堆中，方法区放到本地方法栈中(MetaSpace)。</p><h5 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h5><p>当Eden区满时，触发Minor GC。<br>Full GC触发条件：</p><ul><li>System.gc() 建议full gc</li><li>老年代空间不足，新生代对象转入及创建为大对象、大数组时</li><li>方法区空间不足</li></ul><h5 id="对象存活判断："><a href="#对象存活判断：" class="headerlink" title="对象存活判断："></a>对象存活判断：</h5><p>引用计数（不能处理循环引用）<br>可达性分析 GCRoot对象：1.虚拟机栈中（帧栈中本地变量表）中引用对象 2.方法区中类静态属性引用的变量 3.方法区中常量引用的对象 4.本地方法栈中JNI(即Native方法)引用的对象<br>可达性分析需要在一个能确保一致性的快照中进行，需要暂停所有Java执行线程（Stop The World)，在安全点(Safe Point)执行可达性分析</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>-Xms 堆最小大小(物理内存1/64) -Xmx 堆最大小大(物理内存1/4) -Xmn 新生代大小 -Xss 每个线程的堆栈大小(1M)<br>-XX:NewRatio 年轻代与老年代比值(4) -XX:SurvivorRatio=8 Eden与Survivor比值<br>对象的访问定位：需要两个指针，一个指向堆内实例数据，一个指向对象类型数据</p><p>对象死亡过程：1.GCRoots不可达 2.finalize方法执行过/没有覆盖，如果没执行过则会将对象放到F-Queue中，之后JVM中会有个低优先级的Finalizer线程去执行，稍后GC将对F-Queue中执行过的对象进行小规模标记，若可达则移出队列。</p><p>回收方法区：回收废弃常量过程与回收对象类似，回收无用的类判断需要先判断：1.该类所有的实例都已被回收 2.加载该类的ClassLoader已被回收 3.加载该类的Class对象没有在任何地方被引用，无法通过反射访问该类的方法。</p><p>逃逸分析：如果发现该对象只会被本线程使用（一般是一些局部对象），那么就将该对象在栈上分配，而不在堆中（heap）分配，以减少对象对堆的压力，减少GC的次数。</p><h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><ol><li>加载<br>通过类的全限定名获取定义该类的二进制流 -&gt; 将这个字节流代表的静态存储结构转化为方法区运行的数据结构 -&gt; 生产一个代表这个类的Class对象</li><li>验证<br>文件格式验证 元数据验证 字节码验证 符号引用验证</li><li>准备<br>分配内存(近包括类变量不包括实例变量) 设置类变量初始值(0)</li><li>解析<br>类或接口的解析 字段解析 类方法解析 接口方法解析</li><li>初始化<br>初始化类变量和其他资源。初始化是执行类构造器&lt;cinit&gt;()。JVM会保证父类的cinit方法会先执行（父类的静态代码块也会） JVM会保证一个类的cinit方法在多线程环境中会被正确的加锁、同步。<br>当且仅当 1.new getstatic putstatic invokestatic指令 2.反射调用 3.初始化一个类 4.主类 5.动态语言支持 发生初始化</li><li>使用</li><li>卸载 </li></ol><h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h5><p>每一个类加载器都一个独立的类命名空间，每个类都需要和加载它的加载器一同确立其在虚拟机中的唯一性。<br>启动类加载器(Bootstrap ClassLoader) Cpp实现，其余都是Java实现  加载&lt;JAVA_HOME&gt;\lib目录中的所有类库<br>扩展类加载器(Extension ClassLoader)  加载&lt;JAVA_HOME&gt;\lib\ext 目录中的所有类库<br>应用程序类加载器(Applicatin ClassLoader)  加载ClassPath上制定的类库和类</p><h6 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h6><p>除了顶层的类加载器之外，其余的类加载器都应当有自己的类加载器。这里的父子关系一般不用继承(inheritance)而用组合(Composition)复用。<br>工作过程是：如果一个类加载器接收了类加载的请求，先判断是否加载过，没有则它先把请求委派给父类加载器完成，只有父类加载器反馈自己无法完成这个加载请求，子加载器才会尝试自己加载。<br>优点：Java类具备了一种带有优先级的层次关系。例如java.lang.Object，无论哪个类加载器要加载这个类都将委派给模型顶端的启动类加载器加载。</p><h5 id="帧栈"><a href="#帧栈" class="headerlink" title="帧栈"></a>帧栈</h5><p>局部变量表 操作数栈 动态连接 方法返回地址<br>java方法实现重载的本质：编译期间寻找静态分派目标<br>java方法实现重写的本质：运行期根据实际类型确定方法执行版本</p><h5 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h5><p>内存模型可以理解为在特定的操作协议下，对特定内存或高速缓存进行读写访问的过程抽象。<br>Java线程之间的通信由java内存模型（JMM）控制，JMM决定一个线程对共享变量（实例域、静态域和数组）的写入何时对其它线程可见。<br>每个Java线程都拥有自己的工作内存（保存了该线程使用到的变量的主内存副本拷贝），通过Save和Load操作同步到主内存。</p><h6 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h6><p>保证可见行，禁止指令重排序。<br>Memory Barrier（内存屏障）：1.使编译器和CPU不能对这条Memory Barrier指令重排序 2.强制刷出各种CPU cache<br>内存屏障是volatile的底层实现，volatile常用于双重检查锁和状态标记。</p><p>指令重排序的理解：指令在线程内表现为串行的语义，但是指令并不按代码顺序而是被编译器优化，并且工作内存与主内存同步延迟。final volatile synchronized可以避免</p><p>happens-before：<br>    1、程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。<br>    2、监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。<br>    3、volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。<br>    4、传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。</p><h4 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h4><p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权。<br>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><p><img src="synchronize_lock.jpg" alt="synchronized"><br>监视器锁(monitor)依赖操作系统的mutex lock实现，称为重量级锁。JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><p>轻量级锁：<br>（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如图2.1所示。<br>（2）拷贝对象头中的Mark Word复制到锁记录中。<br>（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为<strong>指向Lock Record的指针</strong>，并将Lock record里的owner指针指向object mark word。如果更新成功，则（4），否则（5）。<br>（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图2.2所示。<br>（5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</p><p>偏向锁：<br>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。<br>（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。<br>（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。<br>（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。<br>（4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。<br>（5）执行同步代码。</p><p>ReentrantLock 可以实现公平锁、锁超时、锁中断、Condition（同一个锁拥有多个等待队列）。</p><p><a href="https://blog.csdn.net/javazejian/article/details/75043422" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/75043422</a></p><h4 id="Java程序排查"><a href="#Java程序排查" class="headerlink" title="Java程序排查"></a>Java程序排查</h4><p>jstack pid 查看当前所有线程运行状态 -l打印锁信息<br>jstat -gc 查看分代各区域的内存大小<br>jstat -class 查看加载类的数量及大小<br>jmap -heap 显示堆使用情况 -histo 展示堆内对象<br>jinfo 查看运行时参数</p><h4 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h4><h5 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h5><h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><p>clone equals finalize getClass hashCode notify notifyAll wait toString</p><h5 id="JNA-JNI"><a href="#JNA-JNI" class="headerlink" title="JNA/JNI"></a>JNA/JNI</h5><p>JNI需要重新编写动态连接库文件，JNA是其替代者，可以不脱离JAVA环境直接调用本地方法。<br>JNA中，它提供了一个动态的转发器，可以自动实现Java和C的数据类型映射。</p><h5 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h5><p>工厂方法getUnsafe()不通过bootloader加载就会抛出异常。<br>通过反射获取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">           Field f = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">           f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">           <span class="keyword">return</span> (Unsafe)f.get(<span class="keyword">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">       <span class="comment">/* ... */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><p>transient 修饰不会被Serializable序列化</p><h5 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h5><p>实际上是Java的语法糖，它只在源码中存在，运行期被替换为Raw Type，并在相应的地方加入强转。</p><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class mClass = testClass.getClass();</span><br><span class="line">Method privateMethod = mClass.getDeclaredMethod(<span class="string">"privateMethod"</span>, String.class, <span class="keyword">int</span>.class);</span><br><span class="line">privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateMethod.invoke(testClass, <span class="string">"Java Reflect "</span>, <span class="number">666</span>);</span><br></pre></td></tr></table></figure></p><h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h5><p>注解通过 @interface关键字进行定义。<br>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。<br>@Retention 保留时期 <code>@Retention(RetentionPolicy.RUNTIME)</code>运行期保留<br>@Documented 将注解中的元素包含到 Javadoc 中去<br>@Target @Target 指定了注解运用的地方<br>@Inherited 子类继承夫类注解<br>@Repeatable 注解的值可以同时取多个。</p><p>注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p><p>注解的提取<br>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解。然后通过 getAnnotation() 方法来获取 Annotation 对象。</p><h5 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h5><p>@FunctionalInterface 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。函数式接口只能有一个抽象方法，比如Converter&lt;T, V&gt; Runnable Comparator<t><br>双冒号(::)操作符将一个常规方法转化为 Lambda 表达式，::new()可以调用初始化函数<br>default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。lambda中默认方法无效。</t></p><p>内置函数式接口：<br>Predicates<t>： 含有一个test方法，一个参数，返回bool值。含有许多默认方法，处理and or negate<br>Functions&lt;T, V&gt;： V apply(T)  默认方法可以将多个函数串在一起（compse, andThen）<br>Suppliers<t>： T get()<br>Consumers<t>： void accept(T)<br>Comparator&lt;T, T&gt;： boolean compare(T, T)  java8添加了默认方法（reversed thenComparing）<br>Optionals<br>Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerEception产生。这个概念在下一节会显得很重要，所以我们在这里快速地浏览一下Optional的工作原理。</t></t></t></p><p>Streams<br>java.util.Stream表示了某一种元素的序列，是在一个源的基础上创建出来的，例如java.util.Collection中的list或者set（map不能作为Stream的源）<br>可以之直接通过调用collection.stream()或者collection.parallelStream() Arrays.stream()方法来创建一个流对象。<br>Filter<br>Filter接受一个predicate接口类型的变量，并将所有流对象中的元素进行过滤。该操作是一个中间操作，因此它允许我们在返回结果的基础上再进行其他的流操作。<br>Sorted<br>Sorted是一个中间操作，能够返回一个排过序的流对象的视图。流对象中的元素会默认按照自然顺序进行排序，除非你自己指定一个Comparator接口来改变排序规则。</p><p>Match<br>匹配操作有多种不同的类型，都是用来判断某一种规则是否与流对象相互吻合的。所有的匹配操作都是终结操作，只返回一个boolean类型的结果。（anyMatch allMatch noneMatch）<br>Count<br>Count是一个终结操作，它的作用是返回一个数值，用来标识当前流对象中包含的元素数量。<br>Reduce<br>该操作是一个终结操作，它能够通过某一个方法，对元素进行削减操作。该操作的结果会放在一个Optional变量里返回。</p><h5 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h5><p><a href="https://blog.csdn.net/javazejian/article/details/71333103" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/71333103</a></p><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><p><a href="http://www.raychase.net/2834" target="_blank" rel="noopener">http://www.raychase.net/2834</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ol><li>搜索二叉树</li><li>根节点是黑色</li><li>红色节点两个子节点都是黑色</li><li>所有叶子节点都是黑色（null）</li><li>从任意结点到其每个叶子节点经过的黑色节点数目相同</li></ol><p>确保了到叶子节点最长的路径不会比最短的两倍还长，保证相对平衡。查找复杂度O(nlgn)<br>右旋：把父节点作为左子节点的右子节点，而原本的右子节点做为新的右子节点的左子节点。左旋相反。<br><a href="https://segmentfault.com/a/1190000012728513" target="_blank" rel="noopener">详细的添加/删除</a></p><h4 id="B树-B-树"><a href="#B树-B-树" class="headerlink" title="B树/B+树"></a>B树/B+树</h4><p>B树：<br>二叉树太深， 因此采用多叉树结构。-&gt;平衡多路查找树结构（B树）<br>一棵m阶的B树：</p><ul><li>树中每个结点<strong>最多</strong>含有m个孩子（m&gt;=2）</li><li>除根结点和叶子结点外，其它每个结点<strong>至少</strong>有[ceil(m / 2)]个孩子</li><li>若根结点不是叶子结点，则至少有2个孩子</li><li>所有叶子结点都出现在同一层</li><li>有k个子节点的节点恰好有k-1个关键字<br>复杂度：<br>logd((N+1)/2)–树高<br>应用：文件系统/数据库/磁盘IO</li></ul><p>B+树：</p><ul><li>节点的子树数和关键字数相同（B 树是关键字数比子树数少一）</li><li>节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据</li><li>非叶子节点仅用作索引，它的关键字和子节点有重复元素 </li><li>叶子节点包含了全部数据，同时符合左小右大的顺序。用指针连在一起<br>复杂度：</li></ul><p>B*树：</p><ul><li>非叶子结点再增加指向兄弟的指针</li><li>非叶子结点关键字个数至少为(2/3)*M</li></ul><h4 id="跳表-SkipList"><a href="#跳表-SkipList" class="headerlink" title="跳表(SkipList)"></a>跳表(SkipList)</h4><p>复杂度</p><h4 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h4><ul><li>根节点不包含字符，除根节点外的每一个子节点都包含一个字符。</li><li>从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符互不相同。</li><li>通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// boolean isWord;</span></span><br><span class="line">    TrieNode[] nodes = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://www.jiuzhang.com/solution/word-search-ii/" target="_blank" rel="noopener">https://www.jiuzhang.com/solution/word-search-ii/</a></p><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><h4 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h4><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><h4 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h4><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><h4 id="树状数组（Binary-Indexed-Tree）"><a href="#树状数组（Binary-Indexed-Tree）" class="headerlink" title="树状数组（Binary Indexed Tree）"></a>树状数组（Binary Indexed Tree）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryIndexedTree</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] bitArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(nlogn) initialization</span></span><br><span class="line"><span class="comment">//public BinaryIndexedTree(int[] list) &#123;</span></span><br><span class="line"><span class="comment">//this.bitArr = new int[list.length + 1];</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; list.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//this.update(i, list[i]);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryIndexedTree</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line"><span class="comment">// O(n) initialization</span></span><br><span class="line"><span class="keyword">this</span>.bitArr = <span class="keyword">new</span> <span class="keyword">int</span>[list.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.bitArr[i + <span class="number">1</span>] = list[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.bitArr.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i + (i &amp; -i);</span><br><span class="line"><span class="keyword">if</span> (j &lt; <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line"><span class="keyword">this</span>.bitArr[j] += <span class="keyword">this</span>.bitArr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add `delta` to elements in `idx` of original array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> idx index of the element in original array that is going to be updated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta number that will be added to the original element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">idx += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (idx &lt; <span class="keyword">this</span>.bitArr.length) &#123;</span><br><span class="line"><span class="keyword">this</span>.bitArr[idx] += delta;</span><br><span class="line">idx = idx + (idx &amp; -idx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the sum of elements in the original array up to index `idx`</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> idx index of the last element that should be summed. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> sum of elements from index 0 to `idx`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixSum</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">idx += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result += <span class="keyword">this</span>.bitArr[idx];</span><br><span class="line">idx = idx - (idx &amp; -idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the range sum of elements from original array from index `from_idx` to `to_idx`</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> from_idx start index of element in original array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to_idx end index of element in original array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> range sum of elements from index `from_idx` to `to_idx`</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> from_idx, <span class="keyword">int</span> to_idx)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> prefixSum(to_idx) - prefixSum(from_idx - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>通过临接表实现，能够进行拓扑需要一个有向无环图（DAG），不断取出入读为0的点。使用一个数组记录所有节点的入度并使用一个队列存放当前遍历到的入度为0的节点。如果排序结束仍然存在入度不为0的节点则说明有环。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = a[end];</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[start] &lt;= p &amp;&amp; start &lt; end) start++;</span><br><span class="line">            a[end] = a[start];</span><br><span class="line">        <span class="keyword">while</span>(a[end] &gt; p &amp;&amp; start &lt; end) end--;</span><br><span class="line">            a[start] = a[end];</span><br><span class="line">    &#125;</span><br><span class="line">    a[end] = p;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qs</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = partition(a, start, end);</span><br><span class="line">    qs(a, start, mid-<span class="number">1</span>);</span><br><span class="line">    qs(a, mid+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000004410119" target="_blank" rel="noopener">其他实现</a></p><h4 id="堆排"><a href="#堆排" class="headerlink" title="堆排"></a>堆排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> currentRootNode, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentRootNode &lt; size) &#123;</span><br><span class="line">            <span class="comment">//左子树和右字数的位置</span></span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">2</span> * currentRootNode + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = <span class="number">2</span> * currentRootNode + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把当前父节点位置看成是最大的</span></span><br><span class="line">            <span class="keyword">int</span> max = currentRootNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; size) &#123;</span><br><span class="line">                <span class="comment">//如果比当前根元素要大，记录它的位置</span></span><br><span class="line">                <span class="keyword">if</span> (arrays[max] &lt; arrays[left]) &#123;</span><br><span class="line">                    max = left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size) &#123;</span><br><span class="line">                <span class="comment">//如果比当前根元素要大，记录它的位置</span></span><br><span class="line">                <span class="keyword">if</span> (arrays[max] &lt; arrays[right]) &#123;</span><br><span class="line">                    max = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最大的不是根元素位置，那么就交换</span></span><br><span class="line">            <span class="keyword">if</span> (max != currentRootNode) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arrays[max];</span><br><span class="line">                arrays[max] = arrays[currentRootNode];</span><br><span class="line">                arrays[currentRootNode] = temp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//继续比较，直到完成一次建堆</span></span><br><span class="line">                heapify(arrays, max, size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arrays, i, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h4 id="旋转数组二分查找"><a href="#旋转数组二分查找" class="headerlink" title="旋转数组二分查找"></a>旋转数组二分查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindXInRotateArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearchInRotateArray</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>, high = a.length-<span class="number">1</span>, mid;</span><br><span class="line"><span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(a[mid] == x)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">if</span>(a[mid] &gt;= a[low]) &#123;<span class="comment">//左边有序</span></span><br><span class="line"><span class="keyword">if</span>(x &lt; a[mid] &amp;&amp; x &gt;= a[low])</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//右边有序</span></span><br><span class="line"><span class="keyword">if</span>(x &gt; a[mid] &amp;&amp; x &lt;= a[high])</span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带有重复数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(a[mid] == a[low] &amp;&amp; a[mid] == a[high]) &#123;</span><br><span class="line">    //low到high遍历</span><br><span class="line">&#125;</span><br><span class="line">if(a[mid] == a[low])</span><br><span class="line">    //递减查找</span><br></pre></td></tr></table></figure></p><p>找轴（最小数字）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(high - low == 1)</span><br><span class="line">    return a[high];</span><br></pre></td></tr></table></figure></p><h4 id="3sum"><a href="#3sum" class="headerlink" title="3sum"></a>3sum</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find3sum</span><span class="params">(<span class="keyword">int</span> dataSet[], <span class="keyword">int</span> itemNum, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, left, right;</span><br><span class="line">    sort(dataSet);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;itemNum<span class="number">-2</span>; i++)&#123;</span><br><span class="line">        left    = i+<span class="number">1</span>;</span><br><span class="line">        right   = itemNum<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum(i, left, right) == key)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"triplet %d %d %d bingo!\n"</span>, i, left, right);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum(i, left, right) &lt; key)</span><br><span class="line">                left ++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> Gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h4><p><a href="https://segmentfault.com/a/1190000003899850" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003899850</a></p><h4 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h4><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><h4 id="生产者消费者-无锁实现"><a href="#生产者消费者-无锁实现" class="headerlink" title="生产者消费者/无锁实现"></a>生产者消费者/无锁实现</h4><h4 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h4><p>构造一个 0 ~ 2^32-1 大小的环。<br>服务节点经过 hash 之后将自身存放到环中的下标中。<br>客户端根据自身的某些数据 hash 之后也定位到这个环中。<br>通过顺时针找到离他最近的一个节点，也就是这次路由的服务节点。<br>考虑到服务节点的个数以及 hash 算法的问题导致环中的数据分布不均匀时引入了虚拟节点。</p><p>实现方法：1. 构造一个排序的Node数组，Node内包含了hash值和节点 2. 使用SortedMap，键为hash，值为节点。<br>查找时寻找比客户端hash值大的节点。</p><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h4 id="Bloom-Filter-反转特性"><a href="#Bloom-Filter-反转特性" class="headerlink" title="Bloom Filter/反转特性"></a>Bloom Filter/反转特性</h4><p>如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。<br>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。</p><h4 id="bitmap-实现"><a href="#bitmap-实现" class="headerlink" title="bitmap 实现"></a>bitmap 实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_BITS sizeof(int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5 <span class="comment">// 2^5=32</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0x1f <span class="comment">// 2^5=32</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1024*1024*1024 <span class="comment">//max number</span></span></span><br><span class="line"><span class="keyword">int</span> bitmap[MAX / INT_BITS];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 设置第i位</span></span><br><span class="line"><span class="comment">* i &gt;&gt; SHIFT 相当于 i / (2 ^ SHIFT),</span></span><br><span class="line"><span class="comment">* i&amp;MASK相当于mod操作 m mod n 运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">bitmap[i &gt;&gt; SHIFT] |= <span class="number">1</span> &lt;&lt; (i &amp; MASK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取第i位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bitmap[i &gt;&gt; SHIFT] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; MASK));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除第i位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bitmap[i &gt;&gt; SHIFT] &amp; ~(<span class="number">1</span> &lt;&lt; (i &amp; MASK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h4><ol><li>分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序<br> 寻找海量数据中次数最多、最大。</li><li>多层划分<br> 寻找相同的值、中位数、不重复个数</li><li>Bloom filter/Bitmap<br> 实现数据字典，进行数据的判重(2位bitmap)，或者集合求交集</li><li>Trie树/数据库/倒排索引<br> Trie树：数据量大，重复多，但是数据种类小可以放入内存<br> 数据库索引：增删改查<br> 倒排索引(Inverted index)：搜索引擎，关键字查询</li><li>外排序<br> 内存受限磁盘排序。多路归并排序。</li><li>MapReduce</li></ol><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><h5 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h5><h5 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h5><h2 id="Cpp"><a href="#Cpp" class="headerlink" title="Cpp"></a>Cpp</h2><h4 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h4><p>然后每个位代表一个数字。<br><a href="https://blog.csdn.net/alps1992/article/details/44599387" target="_blank" rel="noopener">https://blog.csdn.net/alps1992/article/details/44599387</a><br><a href="https://blog.csdn.net/Gimaomao/article/details/77838100" target="_blank" rel="noopener">https://blog.csdn.net/Gimaomao/article/details/77838100</a></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h4 id="单例工厂"><a href="#单例工厂" class="headerlink" title="单例工厂"></a>单例工厂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><h4 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h4><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h5 id="git"><a href="#git" class="headerlink" title="git"></a>git</h5><p>git rebase</p><h5 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h5><h5 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h5><h5 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h5><h5 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h5><p>写时复制从而不影响读。写的时候需要加锁否则多线程先会产生很多副本，之后写复制出的实例，写完之后替换原本的实例。读可以并发。<br>Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet</p><p>需要注意：</p><ul><li>初始化容器大小，避免扩容</li><li>批量写入，复制开销大</li></ul><p>问题：</p><ul><li>内容占用</li><li>只能保证数据的最终一致性，不能保证实时一致性</li></ul><h5 id="Compare-and-Swap-CAS"><a href="#Compare-and-Swap-CAS" class="headerlink" title="Compare and Swap(CAS)"></a>Compare and Swap(CAS)</h5><p>是一种常见的降低读写锁冲突，保证数据一致性的乐观锁机制。<br>Java中例子AtomicInteger，使用Unsafe获取变量值在内存中的偏移地址。变量用volatile修饰，保证内存可见性。将变量地址，变化前后的值传入native方法compareAndSwapInt方法（汇编指令CMPXCHG），返回执行结果</p><p>ABA问题：希望改变的A已经不是最开的A，而是另一个。可使用版本号解决。 Java中解决AtomicReferenceInteger。与AtomicInteger类似，不过保存的值不再是int，而是Pair&lt;V, int&gt;，调用时会比较V和int的stamp值。native方法执行调用的是compareAndSwapObject。</p><h5 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h5><p>并行可切换，并发同时执行</p><h5 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h5><p>互斥：是指某一资源同时只允许一个访问者对其进行访问<br>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br>互斥量值只能为0/1，信号量值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。<br>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p><h5 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h5><p>是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。</p><h5 id="CPU-Cache-与缓存行"><a href="#CPU-Cache-与缓存行" class="headerlink" title="CPU Cache 与缓存行"></a>CPU Cache 与缓存行</h5><p>缓存行 (Cache Line) 便是 CPU Cache 中的最小单位，CPU Cache 由若干缓存行组成，一个缓存行的大小通常是 64 字节（这取决于 CPU），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。<br>伪共享：多个线程同时读写同一个缓存行的不同变量时导致的 CPU 缓存失效。尽管这些变量之间没有任何关系，但由于在主内存中邻近，存在于同一个缓存行之中，它们的相互覆盖会导致频繁的缓存未命中，引发性能下降。</p><h5 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h5><p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html</a></p><h5 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h5><p>“对于扩展是开放的。” 这意味着模块的行为是可以扩展的。当应用程序的需求改变时，我们可以对其模块进行扩展，使其具有满足那些需求变更的新行为。换句话说，我们可以改变模块的功能。<br>“对于修改是封闭的。” 对模块行为进行扩展时，不必改动该模块的源代码或二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或Java的.jar文件，都无需改动。</p><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>. * + ?</p><h5 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h5><h5 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h5><h5 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h5><p>Q: 如果一个进程里有多个线程，其中一个崩溃了会发生什么？<br>A: 依赖进程并且不能与进程分离。线程不是孤立的，因为它们没有自己的地址空间。线程的错误原因可能会终止整个进程或程序，因为该错误会影响该进程或程序中使用的所有线程的整个内存空间。</p><p>Q: 读取一个2G的文件需要多久？为什么？还有哪些因素会影响读取速度？<br>A: iops blocksize</p><p>Q: 轮流打印ABAB<br>A: wait + notify</p><p>Q: 服务假死<br>A:<br>内存/磁盘排查<br>查看连接数(time_wait状态数量)<br>应用服务原因排查：<br>jstat / jstack / jmap + jhat / jvisualVM / OOM dump file / gc.log<br>死锁 / 超过tomcat或dubbo最大连接数 / gc问题 / 线程大量阻塞 / 方法区满</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;OS&quot;&gt;&lt;a href=&quot;#OS&quot; class=&quot;headerlink&quot; title=&quot;OS&quot;&gt;&lt;/a&gt;OS&lt;/h2&gt;&lt;h4 id=&quot;进程线程协程&quot;&gt;&lt;a href=&quot;#进程线程协程&quot; class=&quot;headerlink&quot; title=&quot;进程线程协程&quot;&gt;&lt;/a&gt;进
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第一届POLARDB数据库性能大赛</title>
    <link href="http://lavaoxsea.com/2019/03/06/%E7%AC%AC%E4%B8%80%E5%B1%8APOLARDB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E5%A4%A7%E8%B5%9B/"/>
    <id>http://lavaoxsea.com/2019/03/06/第一届POLARDB数据库性能大赛/</id>
    <published>2019-03-06T02:44:24.000Z</published>
    <updated>2019-03-06T08:19:26.950Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.aliyun.com/polar_race2018/competition_rules?spm=5176.12281978.0.0.a42a76d8AAIieZ&amp;accounttraceid=65e4da1d-b41b-4027-8805-d76009368ec6" target="_blank" rel="noopener">赛题</a>不是很复杂，但是有很多细节。我感觉总体难度还是比较大，我的成绩就是勉强跑出成绩的水平，文章主要以讲解dalao的思路为主。</p><h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>实现一个简化、高效的kv存储引擎，支持Write、Read、Range接口。评测程序分为2个阶段：</p><ol><li>Recover正确性评测<br>此阶段评测程序会并发写入特定数据（key 8B、value 4KB）同时进行任意次kill -9来模拟进程意外退出（参赛引擎需要保证进程意外退出时数据持久化不丢失），接着重新打开DB，调用Read、Range接口来进行正确性校验</li><li>性能评测<br> 随机写入：64个线程并发随机写入，每个线程使用Write各写100万次随机数据（key 8B、value 4KB）<br> 随机读取：64个线程并发随机读取，每个线程各使用Read读取100万次随机数据<br> 顺序读取：64个线程并发顺序读取，每个线程各使用Range*有序（增序）遍历全量数据2次</li></ol><p>顺序读取阶段除了对迭代出来每条的kv校验是否匹配外，还会额外校验是否严格递增，如不通过则终止，评测失败。<br>此外，题目限制了内存大小，C++为2G，Java为3G。这也成为题目的难点。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>由于题目没有给测试代码，首先我先实现了一个测试类。分别测试写入、随机读和顺序读。写入时生成长度为4K的随机串，然后从中计算出8B的键。write操作结束后，将key添加到保存到文件。之后读校验之前将key读到内存里并随机从中取键值，读取出值后计算键值并与当前键值比对。顺序读也类似，按顺序校验值的同时也校验索引。<br>之后需要解决的是kill -9后可以恢复的问题。我参考了这篇文章：<a href="http://imushan.com/2018/06/18/java/language/Java%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E8%90%BD%E7%9B%98%EF%BC%9F/" target="_blank" rel="noopener">Java保证文件落盘</a>。但是这里题目的条件并没有说明断电，因此写入Page Cache不落盘就可以满足要求了。<br>为了将数据存到缓冲区中，又保证kill不丢失，我参考了主流数据库的策略。先将数据存到log中，落盘之后再删除log文件。log是同步写的。打开db时会先将log数据读入并写到db中。<br>为了满足range的要求，我设计了将数据排序的系统。通过ConcurrentSkipListMap来保存键值，因为内存无法保存所有数据，因此每达到1百万条消息后将skipListMap异步落盘，完成后会回调删除log文件。这时，可以保证map内的数据和落盘的数据是局部有序的。根据题目要求，读是在写完成之后并且会重新打开db。因此，我将全局的排序放到了重开db的这个阶段，排序方式就是建一个堆，然后打开刚才所有存储的map做输入流。最终构建出一个排序的key值列表，和对应文件及偏移量。<br>我觉得这套方案理论上是可行的，但是最终没有跑出成绩来，首先我写log的方式是很僵硬的，我需要等待64个线程的消息全部达到才执行一次写入，我也试过32个消息执行一次写入，但是效果也不好。并且频繁的创建文件，这里应该是阻塞了很多时间。其次，排序这个问题是很困扰我的地方。最开始我直接无脑顺序写，之后对索引排序，验证时跳读，但是耗时太长，跑不出结果。之后换成这种局部顺序的方式，不过我没有做缓存，在并发读的时候应该还是存在大量跳读，效果不好。</p><h3 id="dalao解题"><a href="#dalao解题" class="headerlink" title="dalao解题"></a>dalao解题</h3><p><a href="https://www.cnkirito.moe/polardb-race/" target="_blank" rel="noopener">Java实现的系统</a>最终成绩21，我在简要讲讲我的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://code.aliyun.com/polar_race2018/competition_rules?spm=5176.12281978.0.0.a42a76d8AAIieZ&amp;amp;accounttraceid=65e4da1d-b41b-4
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第四届阿里中间件性能挑战赛总结(复赛)</title>
    <link href="http://lavaoxsea.com/2018/10/24/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E9%98%BF%E9%87%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93(%E5%A4%8D%E8%B5%9B)/"/>
    <id>http://lavaoxsea.com/2018/10/24/第四届阿里中间件性能挑战赛总结(复赛)/</id>
    <published>2018-10-24T14:51:22.000Z</published>
    <updated>2019-03-05T13:28:40.589Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://code.aliyun.com/middlewarerace2018/queuerace2018?spm=5176.11409106.555.2.74c16668bKJEqg&amp;accounttraceid=10474bc7-3bc6-46b6-ad68-086faf849447" target="_blank" rel="noopener">复赛题目</a>的描述相对就简单了，但是题目难度就提升了好多……菜鸡如我已经顶不住了，还好有好多大佬打完初赛并不参加复赛了，没有丢人垫底……<br>这里我简单分享下我的思路，再介绍一下dalao们的解决方案……</p><h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>题目提供的信息如下：<br>内容：实现一个进程内的队列引擎，单机可支持100万队列以上。<br>校验程序分为三个阶段： 1.发送阶段 2.索引校验阶段 3.顺序消费阶段 </p><ol><li>各个阶段线程数在20~30左右 </li><li>发送阶段：消息大小在50字节左右，消息条数在20亿条左右，也即发送总数据在100G左右 </li><li>索引校验阶段：会对所有队列的索引进行随机校验；平均每个队列会校验1~2次； </li><li>顺序消费阶段：挑选20%的队列进行全部读取和校验； </li><li>发送阶段最大耗时不能超过1800s；索引校验阶段和顺序消费阶段加在一起，最大耗时也不能超过1800s；超时会被判断为评测失败。<br>至于具体的题目要求选手查看demo了解。</li></ol><p>总结一下，现在需要实现一个QueueStore的子类DefaultQueueStoreImpl。需要能够存储百万数量级的消息队列，验证时并发存和并发读，要求tps能够达到最大。需要实现的接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueStore</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把一条消息写入一个队列；</span></span><br><span class="line"><span class="comment">     * 这个接口需要是线程安全的，也即评测程序会并发调用该接口进行put；</span></span><br><span class="line"><span class="comment">     * 每个queue中的内容，按发送顺序存储消息（可以理解为Java中的List），同时每个消息会有一个索引，索引从0开始；</span></span><br><span class="line"><span class="comment">     * 不同queue中的内容，相互独立，互不影响；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueName 代表queue名字，如果是第一次put，则自动生产一个queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message message，代表消息的内容，评测时内容会随机产生，大部分长度在64字节左右，会有少量消息在1k左右</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String queueName, <span class="keyword">byte</span>[] message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从一个队列中读出一批消息，读出的消息要按照发送顺序来；</span></span><br><span class="line"><span class="comment">     * 这个接口需要是线程安全的，也即评测程序会并发调用该接口进行get；</span></span><br><span class="line"><span class="comment">     * 返回的Collection会被并发读，但不涉及写，因此只需要是线程读安全就可以了；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueName 代表队列的名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 代表消息的在这个队列中的起始消息索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 代表读取的消息的条数，如果消息足够，则返回num条，否则只返回已有的消息即可;没有消息了，则返回一个空的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> Collection&lt;<span class="keyword">byte</span>[]&gt; get(String queueName, <span class="keyword">long</span> offset, <span class="keyword">long</span> num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>难点在于系统的限制，内存8g，其中JVM的堆内存限制为4g。此外还拥有一块 iops 1w 左右；块读写能力(一次读写4K以上) 在200MB/s 左右的超强性能ssd。</p><p>在demo中，有个测试类描述了测试逻辑：</p><ol><li>递增新增消息，取模后得到消息队列的序号，再向消息队列引擎发送序号和当前队列中消息数量，并记录每个消息队列的长度</li><li>随机挑选消息队列，获取它随机连续的十个值，比较其内容是否与索引的序号一致</li><li>与第二步类似，不过它会不断获取十个值直到队列中所有消息被读出。</li></ol><p>其中涉及到一些多线程分工的细节，不展开讲解了。题目禁止使用第三方库，可以看出要实现的逻辑还是很有难度的，也就是需要使用有限制的资源支持海量的消息及百万级的消息队列。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>需要设计一种方式能够高效的存储消息队列，一个很直观的思路是一个文件对应一个消息队列，但是这种方式创建的文件过多，超过操作系统的文件句柄上限。<br>总共要存储的消息为100G，我的想法是分比如200个文件去存储这些消息，那么每个文件的大小约为100M。存储用的文件越多，并发执行时被文件锁阻塞就越少，读写效率也会高一些，但是但是实际验证的测试表明多文件并没有优势，反而占用了过多的资源。<br>然后就是设计存储结构，使put和get尽量能够高效的并发执行。因为消息的数量太大，所以要对消息做索引，写入的时候同时写入索引，读取也是会依据索引读取。索引可以存在文件中，或者是直接保存在内存里。保存在文件中的话相当于再用一个二级索引去查找索引文件，这里我是直接把消息的索引存在内存中了。索引记录的是消息的开始位置，所以在消息文件中还需要记录消息长度。如果为每一条消息都建立一条索引占用过多空间肯定是不可行的，这里我的索引记录的是连续的几条消息的开始位置。put写消息时会等待几条消息的到来，满足长度后写入并记录返回的写入位置和写入消息占用的总长度。get读取时读取能够覆盖所需长度的几个索引记录的信息并从中获取所需消息序列。</p><p>下面描述一下我的实现，代码量其实很小……</p><ul><li>初始化DefaultQueueStoreImpl 创建FILE_NUM个文件。初始化messageListMap和queueMap两个ConcurrentHashMap，一个负责记录每个消息队列未写入的消息，另一个记录每个消息队列的索引。然后对于每个存储消息的文件，创建一个DataAccess对象。DataAccess是负责消息写入文件和读取的逻辑，之后讲解，索引使用一个POJO类Position来表示，拥有三个字段filename、index和size。</li><li>put 不断把消息添加到指定消息队列对应的list中，直到达到MSG_LIST_LEN（一个索引记录的消息量）。对这个list加锁，随机选择一个文件，使用对应的DataAccess对象将消息写入该文件，并把写入的位置、消息长度和文件名组成索引存到queueMap中。</li><li>get 使用queueName参数从queueMap获取能够覆盖offset到offset+size长度的索引列表，把每个索引对应的消息使用DataAccess全部取出来，从中间获取我们需要的部分返回。</li><li>flush 因为读写是两阶段进行的，在写结束后可能有些数据还在list或者buffer中，read之前会先触发一次flush方法。这个flush会把list中的数据使用DataAccess写入文件并调用DataAccess的flush方法。</li></ul><p>DataAccess也采用了一些特殊的设计，使用了<code>FileChannel</code>来负责读写文件。因为JVM限制为了4g，要利用剩余的4g空间可以使用堆外内存。通过ByteBuffer.allocateDirect来创建一个buffer，每个DataAccess都拥有一个这样的buffer。每次写入消息后，将消息写到buffer中去，当buffer满时再写入channel，重置buffer。读取则是通过channel的map方法从文件channel中映射一个MappedByteBuffer对象，在把消息通过消息长度解析出来。写入流和读取流是两个不同的channel，写入流通过append模式<code>FileOutputStream</code>获取，读取流通过r模式的RandomAccessFile获取。写入文件时要对文件加锁，读取则可以并发读。<br>次外，包含一个flush方法把buffer中的数据全部写入文件。</p><p>最后这套流程并不能跑出结果……因为4g内存爆了，直接抛出OutOfMemory错误。不过我当时调整本地测试代码的参数到题目要求是可以跑出结果的……所以一直没有看出问题在哪里，直到我有次错误的把锁加在put方法上，竟然跑出结果了……猜测是因为写入时间已经达到最大而消息还未全部写入，直接进入检索和校验阶段。最终tps为287266.3，就是这个结果勉强让我有个名次……实际上前40的团队已经有一百万的结果，而前十更是怒超2,000,000。其实可以简单算一下，4g内存对我这套流程肯定是不够用的。假设FILE_NUM为1000，MSG_LIST_LEN为50。也就是说索引的记录数为 2,000,000,000 / 50 等于 40,000,000条，一条索引所占内存大约为32bytes，总共约占1.28G。而list中消息的数量为1,000,000 * 50，乘以大小50 + 4bytes，总共约占2.7G。再加上1,000,000个队列名，此时加起来肯定已经超过4g了。我对JVM不是很熟，应该还是少算了一些内存消耗，赛后我感觉主要的一个问题是没有做消息的压缩和解压，压缩过的消息应该能省下不少内存。</p><h3 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h3><p>事实上这次复赛我做的稀烂……而且时间比较紧也没法临时去学，只能赛后再总结学习，还是有很多收获的。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&amp;mid=2247484378&amp;idx=1&amp;sn=1c26663f4c7f1948f8963324356381a3&amp;chksm=96cd4396a1baca8011e0fcef67d182b87aea3fc5323dc1f01fd70f8bb1baba890316bb4bbf58&amp;mpshare=1&amp;scene=1&amp;srcid=0803v2vPPHXvvqjIk7wm5a7C&amp;pass_ticket=7W5zWBa%2F%2BvMoZ%2FofB0ZBRLkzgrHvLM6I44wWI3e40%2Fnvc6yCgvGd1lIDGdOA55wM#rd" target="_blank" rel="noopener">第五名思路</a>，有点复杂，简单讲解下：<br>有N个桶，每个桶对应一个文件，将队列名hash取模后确定桶。并把M个队列的消息merge为一个group作为存储单元，当大小达到16k时进行写入，写入之前对队列排序，使一个队列内的内容按序相邻。<br>设计了两级索引L1和L2，都按时间顺序存放。L2对应一个block，记录了block在文件内的偏移，block大小和每个队列距离block起始位置的偏移。L1对应16个L2索引，记录了存放文件和block内每个队列的起始序号。<br>异步flush：采用RingBuffer接收block块，使用AIO对多个block块进行Batch刷盘，减少IO Copy的次数。<br>读取：二分查找+预读。建立一个缓存结构，类似RingBuffer，buffer与L2索引双向绑定，判断是否可用。</p><p>java IO: JavaAPI中存在三种方式，基于字节流的方式（IOStream），基于buffer的方式（FileChannel），基于Mmap（MapppedByteBuffer）。基于字节的方式是最原始的方式，效率不高。而使用channel可以以buffer为块进行IO操作，和操作系统对磁盘的IO非常相似，此外buffer可以申请堆外内存，减少gc次数。而且可以避免内存的堆内堆外复制。而mmap则会在文件大小为1-1.5G的情况下发挥出最佳性能，它是基于虚拟内存将对文件的操作映射到磁盘上。但是缺点是释放较为复杂而且其使用的虚拟内存不好控制。<br>此外，通过使用Unsafe的方式，java也可以越过page cache来直接操作文件，也就是directIO。<br><img src="linux-io.png" alt="linux-io"></p><p>ssd: ssd需要以4k字节的整数倍进行IO才能获取最大的性能。比赛提供的ssd的性能参考：<br><img src="ssd.png" alt="ssd"><br>因此，这里为了达到最高性能，至少应该以16kb为buffer大小单位进行磁盘读写。</p><p>异步读写：在程序中IO不应该阻塞逻辑线程。这也是很关键的一点。这里可以应用一个生产者消费者魔性，通过一个blockingqueue在异步IO线程和逻辑线程进行交互。</p><p>ThreadLocal：在程序中我因为使用了大量的文件从而为每个文件分配了一个文件操作工具类并分配directBuffer。事实上，少量文件满足需求，并且把buffer存在ThreadLocal中可以方便得管理。</p><p>gc 优化：能用数组的地方不要用 List。尽量减少小对象的出现，可以用数组管理基本数据类型，小对象对 gc 非常不友好，无论是初赛还是复赛，Java 比 Cpp 始终差距一个垃圾回收机制。必须保证全程不出现 full gc。</p><p>在读取整个队列时，通过预读减少IO次数可以显著提高性能。也就是模拟page cache的行为。page cache在内存有限时分配会受影响。</p><p>在读写文件时，顺序读写快于随机读写。因此在读写文件时需要加锁，确保是按顺序写入文件，不会导致文件空洞和跳读以达到最优的性能。但是加锁的顺序读写无法打满磁盘IO（iops）。因此需要进行文件分区，分多少合适呢？文件多了，锁冲突变降低了；文件太多了，碎片化太过严重，单个文件的值太少，缓存也就不容易命中。</p><p>性能优化的万金油</p><ul><li>Batch<ul><li>增加单次IO的吞吐量，目标打满磁盘吞吐</li></ul></li><li>Pipeline<ul><li>提交刷盘任务流水线化</li></ul></li><li>Buffer/Cache<ul><li>写数据，先放buffer，再批量写</li><li>读数据，先放cahce，减少IO</li></ul></li><li>Non-Block<ul><li>异步刷盘/读盘</li></ul></li></ul><p>ssd 4k<br>写：<br>批次/消息区块<br>单独的IO线程<br>读：<br>缓存 LRU（最近最小使用）<br>异步预读</p><p>msgBatch:1k<br>pdkblock:64k -&gt; 存储单元<br>blockpool:3G -&gt; ConcurrentLinkedQueue 调用线程写入，IO线程寻找写满的落盘 （生产者/消费者）</p><p>压缩 ascci 前两位丢弃<br>预读 把40000个block放入Cache，通过blockId判断</p><p>分析<br>写 2e9 put 100G<br>随机读 1e6 get 500M<br>顺序读 2e8 get 10G<br>磁盘 IOPS 10000 吞吐 200mb/s</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://code.aliyun.com/middlewarerace2018/queuerace2018?spm=5176.11409106.555.2.74c16668bKJEqg&amp;amp;accounttraceid=10474bc7-3bc6
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第四届阿里中间件性能挑战赛总结(初赛)</title>
    <link href="http://lavaoxsea.com/2018/09/13/%E7%AC%AC%E5%9B%9B%E5%B1%8A%E9%98%BF%E9%87%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%80%A7%E8%83%BD%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93(%E5%88%9D%E8%B5%9B)/"/>
    <id>http://lavaoxsea.com/2018/09/13/第四届阿里中间件性能挑战赛总结(初赛)/</id>
    <published>2018-09-13T11:01:45.000Z</published>
    <updated>2019-07-28T18:24:52.112Z</updated>
    
    <content type="html"><![CDATA[<p><img src="logo.png" alt=""><br>上个学期抽空打了一下<a href="https://tianchi.aliyun.com/programming/introduction.htm?spm=5176.100066.0.0.6acd33afBcahZs&amp;raceId=231657" target="_blank" rel="noopener">阿里中间件的比赛</a>。作为少见的程序设计竞赛，还是有些收获的。最后的成绩如下：</p><p><img src="result.png" alt=""><br>总体说起来马马虎虎吧，感觉和排行榜顶尖选手的差距还是很大的。后文也会说到他们的技术思路。</p><h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p><a href="https://code.aliyun.com/middlewarerace2018/docs?spm=5176.11409106.555.1.627f6668H7cbDv" target="_blank" rel="noopener">初赛题目</a>非常长，而且复杂。这是第一个难关，要有耐心好好审题，理解要做什么。这里再简单描述下：<br>目标是实现一个Service Mesh，也就是在不改变服务本身的情况下，通过添加以 proxy 或 sidecar 形式部署的 Agent，实现服务的治理（服务注册、负载均衡等）。通过这种方式，所有进出服务的流量都会被Agent拦截，因此可以做到协议的转换，够使得基于不同技术框架和通讯协议建设的服务也可以实现互联互通。<br>service-mesh示例：<br><img src="service-mesh-architecture.png" alt="service-mesh-architecture"></p><p>题目系统架构如下：<br><img src="system-architecture.png" alt="system-architecture"><br>图中所有的服务都运行在Docker容器中。流程是 Consumer 通过 Consumer-Agent 在 etcd 注册服务，通过Dubbo协议进行RPC。Provider 会通过 Provider-Agent 在 etcd 中查找已经注册的 Consumer 服务并向其 Agent 发送RPC的请求。此外，Provider 还向外界暴露RPC调用接口提供调用。Consumer 的调用要做到负载均衡。以上，需要达到最高的qps。</p><p>初赛最nice的地方是提供了一个Demo，让我们这些没见过上面很多技术的人可以大致先了解一下。事实上，我的大部分工作最开始都是基于这份demo。</p><p><a href="https://code.aliyun.com/middlewarerace2018/agent-demo" target="_blank" rel="noopener">Agent示例</a><br><a href="https://code.aliyun.com/middlewarerace2018/services" target="_blank" rel="noopener">Provider 及 Consumer 服务</a></p><p>其中官方提供的 Provider 和 Consumer 是不可以被修改的。它们都是基于Spring-boot的，逻辑较为简单。其中 Provider 提供了Dubbo的RPC服务，暴露了一个IHelloService接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(String str)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现的hash方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String str)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashCode = str.hashCode();</span><br><span class="line">    logger.info(++count + <span class="string">"_"</span> + hashCode);</span><br><span class="line">    sleep(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次调用线程睡眠50ms，模拟运行消耗。该服务需要使用Dubbo协议调用，除此以外不需要其他的Dubbo知识。</p><p>Consumer 就像一个常见的Spring-boot服务，提供了一个控制器。随机生成了1024长度字符串。使用AsyncHttpClient异步地向 Provider 进行RPC的请求，得到返回值并和该字符串的hash值做比较。如果相同则返回值为OK的ResponseEntity，不同则返回值为ERROR的ResponseEntity。示例中还用到了SpringMVC中的异步返回，也就是返回DeferredResult实例。当值被赋给该实例时才会返回。此外AsyncHttpClient库提供了发送异步请求而不阻塞线程的方式，可以学习一下它的API，很实用。具体的函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/invoke"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;ResponseEntity&gt; <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String str = RandomStringUtils.random(r.nextInt(<span class="number">1024</span>), <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"http://127.0.0.1:20000"</span>;</span><br><span class="line"></span><br><span class="line">    DeferredResult&lt;ResponseEntity&gt; result = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    org.asynchttpclient.Request request = org.asynchttpclient.Dsl.post(url)</span><br><span class="line">            .addFormParam(<span class="string">"interface"</span>, <span class="string">"com.alibaba.dubbo.performance.demo.provider.IHelloService"</span>)</span><br><span class="line">            .addFormParam(<span class="string">"method"</span>, <span class="string">"hash"</span>)</span><br><span class="line">            .addFormParam(<span class="string">"parameterTypesString"</span>, <span class="string">"Ljava/lang/String;"</span>)</span><br><span class="line">            .addFormParam(<span class="string">"parameter"</span>, str)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    ListenableFuture&lt;org.asynchttpclient.Response&gt; responseFuture = asyncHttpClient.executeRequest(request);</span><br><span class="line"></span><br><span class="line">    Runnable callback = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查返回值是否正确,如果不正确返回500。有以下原因可能导致返回值不对:</span></span><br><span class="line">            <span class="comment">// 1. agent解析dubbo返回数据不对</span></span><br><span class="line">            <span class="comment">// 2. agent没有把request和dubbo的response对应起来</span></span><br><span class="line">            String value = responseFuture.get().getResponseBody();</span><br><span class="line">            <span class="keyword">if</span> (String.valueOf(str.hashCode()).equals(value))&#123;</span><br><span class="line">                result.setResult(ok);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.setResult(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    responseFuture.addListener(callback, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，题意也基本清晰了。我们需要实现的是两个Agent即 Consumer-Agent 和 Provider-Agent。其中 Consumer-Agent 负责接收 Consumer 的http请求，并通过 etcd 查找 Provider-Agent 服务，从而向 Provider-Agent 发送请求并将结果返回给Consumer。而 Provider-Agent 负责向 etcd 注册，接收来自 Consumer-Agent 的请求，并向 Provider 发送dubbo请求，返回结果给 Consumer-Agent。<br>题目页面上有这么一个展示流程的表格：</p><table><thead><tr><th>通讯环节</th><th>序列化协议</th><th>远程通讯协议</th><th>备注</th></tr></thead><tbody><tr><td>Client =&gt; Consumer</td><td>（无参数传递）</td><td>HTTP</td><td></td></tr><tr><td>Consumer =&gt; Consumer Agent</td><td>FORM</td><td>HTTP</td><td></td></tr><tr><td>Consumer Agent =&gt; Provider Agent</td><td>FORM</td><td>HTTP</td><td>可根据需要自定义</td></tr><tr><td>Provider Agent =&gt; Provider</td><td>JSON</td><td>DUBBO</td><td></td></tr><tr><td>Provider =&gt; Provider Agent</td><td>JSON</td><td>DUBBO</td><td></td></tr><tr><td>Provider Agent =&gt; Consumer Agent</td><td>TEXT</td><td>HTTP</td><td>可以根据需要自定义</td></tr><tr><td>Consumer Agent =&gt; Consumer</td><td>TEXT</td><td>HTTP</td><td></td></tr><tr><td>Consumer =&gt; Client</td><td>TEXT</td><td>HTTP</td><td></td></tr></tbody></table><p>题目中还有一个设定，总共有三个能力不同的 Provider 提供Dubbo的RPC服务，分别为small medium large。因此。我们也需要提供分别对应的 Provider-Agent。Provider 能力不同体现在占用系统资源百分比不同，比例为1:2:3。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><a href="https://code.aliyun.com/middlewarerace2018/benchmarker" target="_blank" rel="noopener">官方配置教程</a><br>比赛所用到的环境都是基于Docker的，因为整体环境较为复杂而且需要做到能够在本地评测分数，当时搭建环境也花了一个晚上，所以这里也稍微介绍一下。<br>系统运行时存在两个角色，一个是施压机，另一个是被压机。可以简单的理解为，被压机用于运行我们的程序，而施压机用于向我们的程序提供输入并接收输出，从而计算qps做为分数。<br>系统简单起见，设置施压机寻找被压机的方式是，修改施压机的host文件，将被压机的域名修改为 shuke.&lt;host-name&gt;。host-name为施压机的主机名。</p><h6 id="被压机"><a href="#被压机" class="headerlink" title="被压机"></a>被压机</h6><p>被压机在测试过程中，被需要被施压机启动相应的环境。因此需要在相应的用户目录下创建.passwd文件，并在其中配置密码。此外，被压机需要安装好Docker环境。</p><h6 id="施压机"><a href="#施压机" class="headerlink" title="施压机"></a>施压机</h6><p>施压集需要配置python运行环境以及pipenv以运行测试脚本。此外还需要配置wrk，用于压力测试。</p><h6 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h6><p>首先启动一个mock server。它是使用python的BaseHTTPRequestHandler和HTTPServer实现的，作用是在POST请求时返回返回一个带有docker镜像路径的JSON串，用于配置测试task。<br>还需要配置一下测试脚本里的bootstrap.conf,具体见官方教程。</p><p><code>pipenv run python bootstrap.py -p &lt;prefix&gt;</code> 启动测试。prefix为hostname前缀。</p><p>整套测试是基于自动化的python脚本，线上环境应该和线下一样。</p><ul><li><p>bootstrap<br>入口，读取logging.yml作为全局<code>logging</code>的配置，输出到console。事实上线上测试是写到文件的。<br>使用<code>argparse</code>读取命令行的<code>prefix</code>参数和配置文件名，默认为bootstrap.conf。通过<code>configparser</code>将配置文件读入<code>Configuration</code>实例<code>config</code>中。<br>将<code>config</code>传入<code>TaskAgent</code>。其作用主要是拉取需要执行的测试任务，因为这里是线下环境，所以我们的任务由前面提到的Mock Server提供。将一些身份信息组为payload，由<code>requests</code>发送post请求Server的url。信息和url都在bootstarp.conf中配置。返回的信息保存为一个<code>Task</code>实例，保存的主要是队伍ID，任务ID，仓库路径，镜像路径，Docker仓库的用户名和密码。（提交代码时也需要上传打包好的镜像，不过阿里云提供自动构建）本地测试的话这些都不需要。<br>以上基本配置完成后，将<code>task</code>和<code>config</code>传入<code>Workflow</code>开始测试流程。</p></li><li><p>workflow<br>初始化中生成<code>Workspace</code>实例，包含<code>local</code>和<code>remote</code>两个成员，分别代表施压机和被压机的工作目录，并且包含属性为相应的路径。<br>随机生成一个五位数的salt。</p><ol><li>__lock_local_workspace()<br>创建local(施压机)的目录环境。尝试创建.lock文件，成功直接返回，失败抛出异常。</li><li>__generate_dockerpwd_file()<br>尝试将task中的docker密码写入.dockerpwd文件，成功返回，失败抛异常。</li><li>__create_remote_task_home()<br>将创建remote(被压机)目录的shell脚本写到一个字符串中，调用<code>__run_remote_script</code>执行。<code>__run_remote_script</code>主要是将脚本用ssh组合起来，之后调用<code>__run_script</code>执行。而<code>__run_script</code>是通过<code>subprocess.Popen</code>的<code>communicate</code>方法执行脚本，获取outs, errs。通过<code>Popen</code>的<code>returncode</code>获取返回值。回到原方法，如果返回值不为0，抛出异常。</li><li>__lock_remote_task_home()<br>和上一个方法类似，不过把shell脚本改为创建.lock文件。</li><li>__upload_dockerpwd_file()<br>同样是内容为一个scp的shell脚本，不过调用的是<code>__run_local_script</code>，这个方法直接调用<code>__run_script</code>在本地执行脚本。</li><li>__docker_login()<br>被压机调用的是docker login的shell脚本，此外docker仓库的密码之前已经被存到文件中，读取之后删除。</li><li>__pull_docker_images()<br>远程执行脚本，读取之前保存在~/.passwd位置的用户密码，sudo调用docker pull拉取我们上传的镜像、etcd镜像、ncat镜像</li><li>__check_signatures()<br>上传的镜像在构建时会拉取provider consumer 和 docker-entrypoint.sh，需要确保未被修改。远程执行脚本，读取.passwd以root权限调用docker run 执行sha256sum和之前算好的值比较。不一致则返回错误码，抛出异常。</li><li>__create_docker_network()<br>远程执行创建docker network的脚本。子网为10.10.10.0/24，网关为10.10.10.1，子网掩码为255.255.255.0。</li><li>__start_etcd()<br>远程执行启动docker etcd的脚本，从config中指定etcd的资源等参数，网络为刚才创建的docker network。在TaskHome目录下创建etcd文件夹，里面创建logs文件夹保存日志文件，启动docker时映射相应位置。此外，docker run还指定了cidfile保存在etcd文件夹内。<br>然后使用ncat镜像连接刚才创建的etcd，尝试MAX_ATTEMPTS次，每次失败sleep一定时间，成功后结束，失败则返回错误码。</li><li><p>__start_providers(salt)<br>过程同上， 不过是启动三个不同规格的provider，提供的是provider镜像需要的参数。ncat连接也是相似的过程。此外还需要将salt值传给启动的docker，但是在docker内entrypoint脚本中并没有用到这个值。</p><p>这里再讲解一下provider及consumer的docker镜像构建及启动过程，也就是Dockerfile。</p><ul><li>复制项目文件到workspace/agent</li><li>将work/agent设为工作区</li><li>mvn clean package</li><li>拉取provider和consumer的jar包复制到指定目录，将项目打成的jar包也复制到目标目录</li><li>拉取docker-entrypoint.sh到目标位置，它的作用是启动Provider和Consumer</li><li>将start-agent.sh复制到目标位置，它的作用是按照我们配置的参数启动Agent</li><li>创建/root/logs为日志目录</li><li>暴露8087端口</li><li>将docker-entrypoint.sh设为ENTRYPOINT<br>docker-entrypoint.sh及start-agent.sh都是简单的脚本文件，docker-entrypoint.sh执行结束后会执行start-agent.sh。都是<code>java -jar</code>方式启动相应的服务，日志保存在镜像里指定的位置，其他主要是type和端口的配置，还有分配的内存大小。docker-entrypoint.sh配置了三种provider和consumer的内存大小，而start-agent.sh则是需要我们手动配置的。</li></ul></li><li><p>__start_consumer(salt)<br>过程同上，启动镜像参数type为consumer。</p></li><li><p>__warmup_then_pressure()<br>热身然后压力测试。本地执行shell脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wrk -t&#123;threads&#125; -c&#123;connections&#125; -d&#123;duration&#125; -T&#123;timeout&#125; \</span><br><span class="line">                --script=./benchmark/wrk.lua \</span><br><span class="line">                --latency http://&#123;hostname&#125;/invoke</span><br></pre></td></tr></table></figure><p>使用partial，传入wrk_timeout和hostname。<br>对于不用的压力，使用相应的threads connections duration。本地测试脚本的线程数为2，连接数分别为64/128/256，测试60s。<br>–latency会输出结果，–script制定了wrk.lua脚本，指定了done函数，规定了输出的格式，包挎QPS，平均响应时间，最大最小响应时间等。通过HTTP响应码来判断请求是否成功（200/300）。<br>然后使用正则表达式从输出的结果中获取每次的QPS。</p></li><li>__stop_services()<ul><li>__stop_consumer()</li><li>__stop_providers()</li><li>__stop_etcd()<br>步骤类似，先从相应的目录读取cidfile，获取容器的cid。调用docker logs，将输出重定向到之前映射容器内部用于保存日志的位置。之后stop &amp; rm</li></ul></li><li>__cleanup()<ul><li>__remove_docker_image() 使用镜像名称做docker rmi操作。我们自己打包上传的镜像名称在task里获取。</li><li>__unlock_remote_task_home() 删除被压机工作目录下的.lock文件</li><li>__unlock_local_task_home() 删除施压集工作目录下的.lock文件</li></ul></li><li>__collect_data()<ul><li>__compute_result() 计算之前得到所有QPS中的最大值作为结果</li><li>__download_logs() 远程执行shell脚本，叫工作目录的所有文件都打包成.tar.gz，保存在当前目录的上一级，文件名为logs。之后本地执行scp脚本将这个文件复制到本地工作目录，将teamId/taskId写入当前目录的.osspath文件。<br>以上基本上就是完成的工作流程，最终如果中途抛出了异常，则返回qps为-1的json串，否则用best_qps组成一个json返回。boostrap得到这个结果后用TaskAgent将结果上传到目标url。</li></ul></li></ol></li></ul><p>整个流程是自动化的，当时在比赛时没有时间细看，现在赛后分析才认真学习了一下，感觉虽然功能并不复杂但还是挺厉害的，而且日志的配置很到位，错误的排查以及流程的确认都很清晰。</p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>现在我们回到题目本身，已经清楚的是Provider和Consumer的输入输出和程序最终的目标，需要实现的是Agent（一个Consumer-Agent和三个Provider-Agent），Agent的代码只有一份，会根据启动的参数-Dtype判断是Consumer还是Provider。<br>Demo中已经为我们实现了一个Agent的样例，是可以跑通的，借此也可以帮助理解Agent具体实现的功能和细节。因为代码稍微有点多，只挑重点说一下流程。<br>这个Agent和之前的Rrovider和Consumer类似，使用了Spring-boot来处理请求和响应。</p><p>使用<code>HelloController</code>作为程序的入口，定义了一个<code>EtcdRegistry</code>成员用于服务注册和服务发现。<code>EtcdRegistry</code>是一个工具类，使用初始化时传入ip地址。etcd是一个基于Go的高可用强一致性的服务发现存储仓库，<a href="https://linux.cn/article-4810-1.html" target="_blank" rel="noopener">这里</a>有一篇介绍，不展开讨论了。etcd在系统中负责服务的注册与发现并提供负载均衡的能力，完成题干中描述的两项任务。实际上我们只需对样例稍加修改就可以直接使用代码。不过etcd的负载均衡能力是基于多个etcd节点的，这里我们还是需要自己实现。<br><code>EtcdRegistry</code>中主要使用了coreos的jetcdAPI，通过传入IP来创建endpiont，然后创建lease。它拥有超时时间和唯一ID。之后启动一个线程向etcd发送心跳包，保持连接。通过系统参数判断是Provider还是Consumer（Agent），如果是Provider则进行服务注册，构造键值并传入etcd。键由预定义头、服务名、IP和端口组成，值为空。如果为Consumer则会用预定义头和服务名去查找所有满足的键值对，用获取到的IP和端口构造endpoint列表返回。</p><p>回到Controller，仅提供了一个接口invoke。传入的dubboRPC所需的参数。在invoke内部会根据系统参数判断Provider和Consumer，并依此调用相应的方法。接下来按流程讲解一下（先Consumer再Provider）</p><ul><li>Consumer的流程：使用okhttp库向之前通过etcd查找出来的endpoint以随机选择一个的方式发送请求，并等待响应返回。</li><li>Provider的流程：生成一个RpcClient实例，用于向Dubbo发送请求。RpcClient的invoke方法中构造了一个Request的POJO实例，设置了一些Dubbo请求首部的字段，该程序中意义不大不赘述，然后创建了一个PRCInvovation的POJO实例，把方法的参数（Dubbo的请求体）设置到该实例中。使用<code>DataArrayOutputStream</code>和JsonUtil将PPCInvocation作为JSON的byte数组设为Request的一个属性data（Provider要求）。此外Request还拥有一个成员id，使用<code>AtomicLong</code>保证自增，唯一标识一个对象。现在我们有构造好的Request实例了。<br>* 接下来是示例中的重点：<br>首先我们应该明确的是接下来我们需要做的是向Dubbo发送RPC请求并接受结果，此时应该使用的是Dubbo协议（题目附录中有简要介绍），在这里使用了一个很重要的第三方库，Netty。在RpcClient中有一个成员ConnectManager，完成了初始化bootstarp的操作。在我们的invoke操作中从ConnectManager中获取了channel的单例（provider-agent和provider是一对一的关系），并把request写入其中。之后，我们需要获取请求结果，这里也有点意思。实例提供了一个RpcRequestHolder类，里面有一个<code>ConcurrentHashMap</code>成员并提供了get set方法，在发送请求前，创建了一个RpcFuture实例用于接收返回的结果然后把唯一的请求id作为键，RpcFuture作为值存到RpcRequestHolder中去。netty在接收到返回后会通过reponse中携带的requestID来找到对应的RpcFuture并把内容写到其中。RpcFuture中还包含了一个RpcResponse实例，等同于响应的byte数组。在发送完向channel中写入请求后，invoke方法会调用RpcFuture的get方法等待响应的结果。在RpcFuture中有一个<code>CountDownLatch</code>值为1的实例，在netty写入reponse后会将其减一。get方法会调用<code>CountDownLatch</code>的<code>await</code>方法等待它的值为0并返回结果。</li></ul><p>至此，一套完整的流程已经结束，除了一个部分，netty处理dubbo协议的编解码，处理响应（因为这里的netty作为一个客户端）。也即是<code>ChannelInitializer</code>的内容。一共用到三个类，DubboRpcEncoder用于编码，DubboRpcDecoder用于解码，RpcClientHandler用于处理响应。</p><ul><li>DubboRpcEncoder 继承了<code>MessageToByteEncoder</code>类， 在<code>encode</code>方法中把message(request)写到buffer(ByteBuf)中。包括两部分：写入首部，写入消息体。过程如下：记录当前buffer的index，把buffer的index设为当前index+首部length，写入json序列化后的信息体，然后重置index并写入首部。其中JSON序列化是题目中dubbo要求的，使用了阿里的<code>SerializeWriter</code>和<code>JSONSerializer</code>序列化对象。</li><li>DubboRpcDecoder 与encoder类似，用于解码dubbo协议，获取消息体。不过这里有个常用操作，检查buffer可读字节的长度，如果每有超过首部长度或者超过了但是没有超过整个消息的长度（通过首部内的长度字段判断），会重置<code>ByteBuf</code>读取的index。直到没有可读数据退出。解码后，会将消息体封装为<code>RpcResponse</code>，交给接下来的handler处理。</li><li>RpcClientHandler 通过RpcResponse内的id，从之前保存RpcFuture的RpcRequestHolder中获取对应的RpcFuture，调用done方法来去除<code>CountDownLatch</code>的锁，返回dubboRPC的结果。<br>示例的qps线上测试的结果在900左右。</li></ul><p>接下来的内容是我修改这个示例的过程：</p><h6 id="version-1"><a href="#version-1" class="headerlink" title="version 1"></a>version 1</h6><p>首先想到可以修改的是Agent Consumer请求Agent Provider的OKHttp这块的内容。Consumer发送请求使用的是AsyncHttpClient，要在有限的资源限制情况下获取尽可能高的资源利用率，Agent也可以使用这种方式，这一步操作我在比赛中并没有做……我一开始就去把agent之间的通讯替换成了netty的方式。</p><p>示例中agent与consumer交互是我第一次接触netty，这种异步的交互方式刷新了我的认知，感觉这种方式很强无敌。于是我觉得使用netty来替代agent之间的spring boot会显著的提高qps。但其实并不是这样，当时还没有理解netty的异步特性。我做的操作就是模仿示例中netty与dubbo交互，不过channelpipline内部的内容修改了。</p><p>分为客户端和服务端简要讲解下，客户端是consumer-agent，服务端是provider-agent。客户端把使用okhttp发送请求更换为netty客户端发送请求。创建了一个ConsumerAgentClient类，因为要发送的是dubbo RPC的相关参数，而且后面在服务端会把这些参数组装为RpcInvocation，索性我直接就在客户端直接将对象封装好，之后服务端直接传递就行。这里我也和实例一样是通过RPCFuture阻塞直到数据返回（事实上这里就是性能提升的关键）…… ConsumerAgentClient会使用AgentConnectManager获取channel，AgentConnectManager管理了netty客户端的创建和管理。这里我又照抄了示例中的ConnectionManager……也就是说我的consumer-agent只会和一个provider-agent建立连接😂</p><p>不过这里我并没有直接使用实例中的ByteToMessageDecoder作decoder的基类，而是使用了LengthFieldBasedFrameDecoder。实例中provider需要不断去判断数据包的长度，这些工作完全可以由LengthFieldBasedFrameDecoder替我们完成。需要设置的参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MAX_FRAME_LENGTH = 4 * 1024; //最大帧长度</span><br><span class="line">LENGTH_FIELD_LENGTH = 4; //长度字段长度</span><br><span class="line">LENGTH_FIELD_OFFSET = 0; //长度字段距离帧头部偏移量</span><br><span class="line">LENGTH_ADJUSTMENT = 0; //长度调整量（是否要去掉头部长度，取决于长度字段的计算方式）</span><br><span class="line">INITIAL_BYTES_TO_STRIP = 0; // 丢弃首部的字段长度，比如解析出来没有用处的首部可以直接丢弃</span><br></pre></td></tr></table></figure></p><p>这里decode解析的帧格式为 长度 + requestId + 内容数据。之后通过requestId去holder中获取future中断阻塞。<br>服务端的内容就相对简单一些，同样通过decode来解析得到客户端发送的requestId和RpcInvocation对象，去holder中按requestId存储RpcFuture。在decode之后服务端还有一个inboundhandler负责处理业务逻辑。这里就是执行之前agent-provider在controller中的逻辑。<br>当然最后这个方式最终跑出来的结果惨不忍睹……qps大约就100……因为整个系统阻塞的太严重，原本基于spring-boot的bio还是一个请求对应一个线程，现在全部阻塞在一个线程上了。</p><h6 id="version-2"><a href="#version-2" class="headerlink" title="version 2"></a>version 2</h6><p>首先把consumer-agent请求provider-agent的channel由一个单例channel改为按hostIP:channel的键值对存到map中……解决了这个显而易见的bug。<br>虽然阻塞问题没解决，不过我还是在这里做了一个小改进，在provider-agent decode之后的AgentServerHandler中，原本是执行在线程中阻塞的逻辑，我把这段逻辑封装到一个Runnable中，然后提交到一个初始化时创建好的线程池中去执行，感觉这里有点Reactor模式的意思。这种方式一定程度上提高了provider-agent的利用率，这种情况下我的qps达到了1400。</p><h6 id="version-3"><a href="#version-3" class="headerlink" title="version 3"></a>version 3</h6><p>这个时候排行榜前100已经是5000左右的水平，我的代码有一些很重要的地方有问题，我终于意识到<code>CountDownLatch</code>就是万恶之源。之前对异步操作的理解不深，现在再回顾一下现有系统，consumer-agent中netty客户端发送请求，之后阻塞，等待服务端的响应。provider-agent的netty服务端收到请求后，在最后一个inboundhandler中使用netty客户端向provider发送请求，之后阻塞等待provider返回结果并向consumer-agent返回结果。</p><p>在异步执行的过程中，无意义的阻塞会耗费大量系统资源。因此这个版本主要解决的就是这个问题。让我们先解决后一个阻塞。首先我们不再使用RPCFuture及其内部的<code>CountDownLatch</code>，这里的思想是，我们不再等待数据的返回，而是当数据返回后回调响应的逻辑。也就是provider向provider-agent返回数据后，我们不等待这个数据的到达再返回给consumer-agent，而是直接执行下一步操作。代码中provider-agent最后得到返回数据是在AgentServerHandler类中，我们要在这里执行返回给consumer-agent的回调操作，即在provider-agent与consumer-agent交互的channel中写入数据。因为题目中provider-agent只会对应一个consumer-agent，所以我们可以在provider-agent中保存他们建立的channel。我把这个channel放在了ChannelHolder中，保证AgentServerHandler对其的访问。</p><p>接下来处理前一个阻塞，也就是consumer-agent收到provider-agent返回的数据，要返回给consumer。因为这里consumer-agent还是用spring-boot处理http请求，因此需要一些特殊的技巧。在Spring3.0后有了异步返回数据的概念，通过<code>DeferredResult</code>实现，具体可以自行查阅资料。在controller中，直接返回<code>DeferredResult</code>实例，等到它的内容被设置，才会回调执行返回数据，整个过程也是异步的不会产生阻塞。这样需要改造的阻塞操作就容易实现了，在consumer-agent中的netty客户端接受返回的AgentClientHandler中设置<code>DeferredResult</code>对象的内容就可以。这里还涉及到一个如何寻找到这个<code>DeferredResult</code>对象的问题，我的解决方案是：每次请求会用<code>AtomicLong</code>设置一个自增不重复的id来唯一标识一次请求，同时对应一个<code>DeferredResult</code>对象。每次创建<code>DeferredResult</code>对象时将其存到一个map中，键为id。之后的过程中发送请求和返回响应都携带这个id，最终就能通过这个id找到<code>DeferredResult</code>对象。<br>线上测试证明这种方式是行之有效的，qps首次突破4k。</p><h6 id="version-4"><a href="#version-4" class="headerlink" title="version 4"></a>version 4</h6><p>虽然spring-boot的异步方式确实性能不差，但是如果consumer-agent使用一个netty服务端来用更加纯粹的异步方式处理响应，可以更加高效的利用资源。此时spring-boot已被弃用，程序运行时会根据参数启动响应的netty服务端。<br>这里consumer-agent中的netty服务端要处理http请求，所以channelpipeline需要做相应调整，使用了<code>HttpServerCodec</code>,<code>HttpObjectAggregator</code>。这些类可以方便的帮我们将http报文中的内容封装成<code>FullHttpRequest</code>对象，传递给我自己实现的HttpConsumerHandler。经过字符串处理可以获得所需的rpc参数值，以上完成了原本由springmvc负责的部分。这里的netty服务端还有一点不同的是他要处理的连接的数量不再是1而是客户端的数量。以前保存deferredresult实例的map，现在需要保存channel对象，使之后的consumper-agent中的netty客户端可以异步向channel中写入响应。当然编码为http报文的工作还是交给<code>HttpClientCodec</code>完成的。<br>这个版本的效果差不多进入200名的及格线，在配置了一下相关参数后qps可以达到5400。</p><h6 id="version-5"><a href="#version-5" class="headerlink" title="version 5"></a>version 5</h6><p>既然整体流程已经是纯异步了，那可以提升的都是细节内容了。除了一个之前一直忽略的东西，provider-agent的负载均衡处理。在这之前，一直依靠的是轮询provider-agent来发送请求，这里我的想法是依据当前provider-agent的负载情况来发送请求。这里我考虑的负载情况可以用每个provider-agent还没有处理完的请求数量来表示。而每次我们都给其一个全局唯一的id，之前的版本我们是使用这个id来对应consumer和consumer-agent交互使用的channel，每次处理完从map中去除。如果我们能够把这个对应的map拆分为三个，每个provider-agent拥有一个，通过统计map键的数量就可以得到当前provider-agent处理的负载。发送请求时直接把请求发送给负载最小的agent即可。（不过现在回想由于agent的处理能力资源并不相同，可能这样方式还不是最优解）<br>稍微讲解一下具体的实现。负责发送请求的ConsumerAgentClient类持有一个map，键为host值为map对象（键为requestId，值为channel），分别对应不同provider-agent。初始化与每个provider-agent连接时，传入对应的channel，最终传入到负责异步写给consumer响应的AgentClientHandler，再写操作完成后会从map中去除requestId。每次发送请求会先检查每个map键的数量，取最小的向其中插入requestId和channel。<br>最终这个版本的效果提升并没有想象的大，qps为5600。</p><h6 id="version-6"><a href="#version-6" class="headerlink" title="version 6"></a>version 6</h6><p>其实到了这个时候我已经想不到什么改进了，做了很多失败的尝试，最终还是在有个不大不小的改进。查询了许多netty资料后，偶尔了解到有个叫做protobuf的序列化方式，比java自带的序列化方式快很多。netty的操作中有把对象写入成字节序列的，所以我想用protobuf来改进试一下。这里需要序列化的只有从consumer-agent向provider-agent发送的AgentRequest(id+RPCInvocation)对象，其他传输的都是byte数组。使用protobuf创建了一个ProtoRequest.java文件用来代表AgentRequest这个对象。在ConsumerAgentClient中sendRequest方法把创建ProtoRequest并写入channel，并把consumer-agent原本继承<code>MessageToByteEncoder</code>的CustomerAgentEncoder替换为<code>ProtobufVarint32LengthFieldPrepender</code>和<code>ProtobufEncoder</code>，并把provider-agent中的netty服务端<code>LengthFieldBasedFrameDecoder</code>及ProviderAgentDecoder替换为<code>ProtobufVarint32FrameDecoder</code>和<code>ProtobufDecoder</code>。<br>这就是我得出最高成绩的版本，qps5976.4，因为没有上6000逼死强迫症，又各种尝试最后还是没有能更近一步。</p><h3 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h3><p>答辩会上top10成绩的选手展示了他们的思路，其中有不少可以借鉴和学习的地方。另外也有一些相关的开源代码，接下来探讨一下可以改进的地方：</p><p>provider-agent和consumer-agent中EventLoop应该共享。当通过ServerChannel创建子channel后，子channel使用connect创建一个新的通道。如果共享了EventLoop则会使之在管道间共享，消除了额外的线程创建和所有相关的上下文切换的开销。<br>具体的做法也有点巧妙。这里以consumer-agent为例， 要使eventloop能够复用，在consumer-agent建立ServerBootstrap时使用了一个worker eventloopgroup，然后需要将其中的eventloop绑定到连接provider-agent的channel中。做法是，对于worker中的每一个eventloop都需要去建立一个bootstrap并作为其中的eventloopgroup，那么该bootstrap建立的所有连接都会被绑定到该eventloop。从而可以保证输入channel与输出channel是复用了一个eventloop的。此外，输入channel找到输出channel的方法是通过查找一个map&lt;eventloop, channel&gt;。</p><p>consumer-agent解码http请求时，有<code>HttpPostRequestDecoder</code>和<code>QueryStringDecoder</code>，后者更快。不过我的实现里是直接处理bytes数组，理论上效果更好。</p><p>使用 netty 自己封装的 EpollSocketChannel 来代替 NioSocketChannel。效果非常明显，题目环境下可以提升300qps。NioSocketChannel使用了jdk提供的nio，在linux下也会选择使用epoll，但是效果不好，可能是netty封装epoll带来的优化。才外使用边缘触发替代水平触发可以减少cpu的负载。</p><p>批量flush，批量decode。不再是writeAndFlush，而是多次write后flush一次。从而减少网络io的次数。decode同理。flush具体是通过重载ChannelOutboundHandler实现，重写其write方法。</p><p>其他细节：<br>    -Dio.netty.leakDetectionLevel=disabled 关闭ByteBuf 进行内存泄露的检测。<br>    EpollChannelOption.TCP_QUICKACK 开启TCP quick_ack<br>    ChannelOption.TCP_NODELAY<br>    减少对象的创建，encode和decode压缩到handler里去处理，hardcoding。</p><p>提升：<br>consumer的CPU是瓶颈，减少consumer-agent的开销<br>consumer-agent 透传？ 不解析consumer的http协议而是做纯粹的转发</p><p>线程数 CA3 PA1<br>RCVBUF_ALLOCATOR: FixedRecvByteBufAllocator</p><p>dalao的坑：透传希望能够做到零拷贝（splice） netty也有支持的方法spliceTo，但是linux不支持socket直接写到另一个socket，中间有pipe作为buffer（内核态）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;logo.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;上个学期抽空打了一下&lt;a href=&quot;https://tianchi.aliyun.com/programming/introduction.htm?spm=5176.100066.0.0.6acd33afBca
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划初探</title>
    <link href="http://lavaoxsea.com/2018/07/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98/"/>
    <id>http://lavaoxsea.com/2018/07/19/动态规划实战/</id>
    <published>2018-07-19T09:31:42.000Z</published>
    <updated>2019-02-25T16:41:00.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>动态规划（DP）问题是一道坎。相信很多人都有这种感觉，它是中高难度题的常客，蕴含了程序设计的经典思想。</p><p>这种技法或者说思想难以掌握是有原因的。它的核心目标是全局最优，而不是局部最优，这是反直觉的。人脑不是机器，所以我们往往陷入贪心的想法。我第一次遇到背包问题的时候，直接的想法是把物品按 价值/重量 排序，再依次取。这就好比小偷作案，总是先挑价值高又轻便的拿。但是这种经验并不是最优解。</p><p>说到背包问题，第一次看到正解后过了很长时间才真正理解。写本文之前，又读了一遍背包九讲(<a href="https://raw.githubusercontent.com/tianyicui/pack/master/V2.pdf" target="_blank" rel="noopener">pdf</a>)。确实背包问题是经典的DP问题，也是对我影响最深的DP问题。推荐对DP有一定理解之后再读。</p><p>写这篇博客之前，我对DP也是有些畏惧的，做题属于碰运气，有时能A，有时不行，还有些时候我都不清楚是要用DP解题。于是花了2周多的时间，刷了一些leetcode上的DP题目。</p><p><img src="leetcode.png" alt="leetcode"></p><p>目前算是初窥其貌，结合一些看到别人的总结，通俗得讲下我的理解。</p><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>如果说DP的核心目标是寻找全局最优解，那这个最优解是如何确保的呢？通过划分子问题，DP问题常常是需要多步的决策，如背包要挑选物品。这些子问题往往是迭代的，一个自问题依赖于另一个的解。每个自问题都能到达最优解就获取到全局最优。因此可以说DP问题就是如何划分子问题并找到子问题的解。</p><p>从上面的描述里可以明显感觉到一个词，迭代。在我看来，迭代是符合人类思想的解决DP问题最直观的方式。</p><p>举个栗子：</p><p><img src="edit_distance.png" alt="edit distance"><br>来自leetcode72题，难度为hard。这道题我花了很久才做出来……而且回顾的时候又花了很久……</p><p>其实题目并不是特别难，但是看起来比较吓人。hard级的题目中DP都不是很直接，需要一定的转换。</p><p>根据题意，核心目标是匹配上两个字符串，通过delete、replace、add三种操作。那么子问题也就相对直接了，两个字符串的子串的匹配加上变成子串的步数即为结果。</p><p>这里我的想法是有三种策略：</p><ol><li>将str1的首字母替换为str2的首字母</li><li>删除str1的首字母，str2不变</li><li>找到str1中str2首字母出现的第一个位置，删除它及之前的所有字母，删除str2首字母。</li></ol><p>当str1和2中有一方为空时，删除另一方全部字母或添加一方全部字母即可，也就是步数加上剩余一方的长度。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">1</span> + getRes(i + <span class="number">1</span>, word1, str, map);</span><br><span class="line">res = Math.min(res, <span class="number">1</span> + getRes(i + <span class="number">1</span>, word1, str.substring(<span class="number">1</span>), map));</span><br><span class="line">res = Math.min(res, index + getRes(i + <span class="number">1</span>, word1, str.substring(index + <span class="number">1</span>), map));</span><br></pre></td></tr></table></figure></p><p>其中<code>getRes</code>为对子串递归调用。</p><p>但是这种解法直接提交以后出现TLE，超时错误。原因很简单，计算了重复状态。这里就可以引出DP中的常规操作，剪枝或者说记忆化搜索。我的代码中是使用了一个map来保存状态，通常更常用的方法是用一个数组记录。</p><p>完整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    IntStream.range(<span class="number">0</span>, word2.length() + <span class="number">1</span>).forEach(x -&gt; map.put(word2.substring(x), <span class="keyword">new</span> Integer[word1.length() + <span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> getRes(<span class="number">0</span>, word1, word2, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRes</span><span class="params">(<span class="keyword">int</span> i, String word1, String str, Map&lt;String, Integer[]&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(str)[i] != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> map.get(str)[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= word1.length())</span><br><span class="line">        <span class="keyword">return</span> str.length();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> + getRes(i + <span class="number">1</span>, word1, str, map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res = Math.min(res, <span class="number">1</span> + getRes(i + <span class="number">1</span>, word1, str.substring(<span class="number">1</span>), map));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = str.indexOf(word1.charAt(i));</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            res = Math.min(res, index + getRes(i + <span class="number">1</span>, word1, str.substring(index + <span class="number">1</span>), map));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.get(str)[i] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>很多时候，动态规划问题的子问题并不好找。通过动态规划做题的经验我们知道有个叫递推方程的东西。而常见递推方程中递推的就是状态，也就是状态转移的过程，寻找状态的转移而去解决子问题是常见的思路。</p><p><img src="interleaving_string.png" alt="interleaving_string"></p><p>题目为leetcode97，由题意，需要用s1和s2组装成s3。s3从0到s3.length的长度都可以由s1和s2组成（子问题），s1和s2的组成方式则可以由i和j的二维数组表示。i代表s1的位置（substring(0, i)），j代表s2的位置。状态转移为<code>len = i + j - &gt; len + 1 = i + 1 + j / len + 1 = i + j + 1</code>满足相关位置的字符相同即可转移。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1.length() + s2.length() != s3.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s3.length() + <span class="number">1</span>][s3.length() + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s3.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.length() &gt;= i -j &amp;&amp; dp[j][i-j -<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; s1.charAt(i - j - <span class="number">1</span>) == s3.charAt(i -<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[j][i - j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s2.length() &gt;= i -j &amp;&amp; dp[i-j -<span class="number">1</span>][j] == <span class="number">1</span> &amp;&amp; s2.charAt(i - j - <span class="number">1</span>) == s3.charAt(i -<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i - j][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s2.length()][s1.length()] == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很多DP的文章都在强调寻找递推式，但是递推式是靠近结果的一步。<strong>寻找递推式的过程，是划分子问题或者表示状态并得到状态的转移。</strong></p><h2 id="一些理论"><a href="#一些理论" class="headerlink" title="一些理论"></a>一些理论</h2><p>知乎上关于理解动态规划也有许多回答，多是关于理论和概念的。能够用动态规划解的题目，状态都具有这两种特性。</p><blockquote><p>最优子结构: 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到<br>无后效性: 而不管之前这个状态是如何得到的</p></blockquote><p>做到一些dp题的时候，我感觉DP和DFS（广度优先搜索）的过程十分相近。例如一个网格，需要从左上角通过向下向右走到右下角，节点带权值。再理解动态规划之前，这对我来说就是走过所有节点并取走过该节点时最小值的问题。这里有一个解释：</p><blockquote><p>每个阶段只有一个状态-&gt;递推<br>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心<br>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索<br>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。<br>                  ——<a href="https://www.zhihu.com/question/23995189/answer/35429905" target="_blank" rel="noopener">知乎</a></p></blockquote><p>这一段话是描述这几种常用算法和状态之间的关系的精髓。需要仔细想想，此处就不再赘述。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>实践出真知。在做了一定量的题目之后，会有自己的总结与归纳。动态规划的状态描述是个难点，一般都是用数组来保存状态。</p><ul><li>最常见的是数组的维度代表状态位置，比如一个二维数组中的某个值。</li><li>数组的维度可以表示状态的维度，所有维度组合为当前状态。</li><li>用pal[start][end]来存储状态，start和end分别代表位置。</li><li>用数组的第一维表示迭代的层数，第二维表示位置.</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>刷了动态规划的题，直观的感受是，我如果知道要用DP解题，80%以上的Medium都可以解出来，但是hard估计也就50%不到。首先如何识别一道题是需要DP解题的问题？这估计只有在以后的实战中判断了。hard级别的动态规划难点也主要在它的不直观或者说需要多绕一个弯，可能根据题意本身解题会一头雾水，但是换个角度就豁然开朗，这需要的就不只是DP的掌握了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;p&gt;动态规划（DP）问题是一道坎。相信很多人都有这种感觉，它是中高难度题的常客，蕴含了程序设计的经典思想。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用hexo搭建Blog</title>
    <link href="http://lavaoxsea.com/2018/07/15/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BABlog/"/>
    <id>http://lavaoxsea.com/2018/07/15/使用hexo搭建Blog/</id>
    <published>2018-07-15T11:39:22.000Z</published>
    <updated>2019-11-24T16:32:13.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 –<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo</a>文档</p></blockquote><p><img src="hexo_intro.png" alt="hexo"></p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>基于node.js和npm。它生成静态页面，对使用者而言高度封装，几乎不需要前端知识，各种已有主题又十分美观，而且切换也十分方便，可以说是个人博客的完美选择。</p><h2 id="安装（MacOS）"><a href="#安装（MacOS）" class="headerlink" title="安装（MacOS）"></a>安装（MacOS）</h2><p>安装git <code>brew install git</code><br>安装npm <code>wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</code><br>重启终端 <code>nvm install stable</code><br>安装hexo <code>npm install -g hexo-cli</code></p><p>##基础配置<br>_config.yml包含了博客的大部分配置，配置内容可在文档中查看。</p><p><img src="dir.png" alt="展示"></p><ul><li>source 存放文章<ul><li>_drafts 存放草稿，默认不显示</li><li>_posts 存放文章</li></ul></li><li>themes 存放主题</li><li>scaffolds 模版，新建文章时受模版控制</li><li>public 存放生成的html等文件</li></ul><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p><code>hexo init &lt;folder&gt;</code> 在文件夹中初始化hexo<br><code>hexo new [layout] &lt;title&gt;</code> 新建文章，layout指draft或post，draft为草稿，post为发布的文章<br><code>hexo generator</code> 将markdown转为静态页面<br><code>hexo publish [layout] &lt;filename&gt;</code> 发表草稿，将draft中指定的文件转到post中<br><code>hexo server</code> 启动hexo服务器，默认端口4000，可以通过-p设置<br><code>hexo clean</code> 清除缓存文件和已经生成的静态文件<br><code>hexo list</code> 展示网站信息</p><h2 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h2><p>包含大量非Markdown语法，不便迁移，尽量不使用。两个例子：</p><p>引用块:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure></p><p>代码块:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题页</a>包含了主题展示和github跳转，按照github项目中README安装即可。</p><p>本人使用的是<a href="https://github.com/kywk/hexo-theme-casper" target="_blank" rel="noopener">casper的修改版</a>。<br>所有和主题相关的文件夹都在themes中并且是可以自定义和修改的，主题目录下提供了_config.yml文件。比如图标、logo、favicon等。此外，可以进一步通过修改js和css为你想要的样式。</p><h2 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h2><p>如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 <img src="/images/image.jpg" alt="">的方法访问它们。</p><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。</p><h2 id="about页面"><a href="#about页面" class="headerlink" title="about页面"></a>about页面</h2><p><code>hexo new page about</code> 创建页面。<br>修改Front-matter部分，layout为false，comments为false</p><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>本人使用了valine，主要工作是取theme文件夹里修改相关的代码。有些主题提供了一些评论系统，直接配置即可。</p><p><a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">官方教程</a>过程很简明。先去LeanCloud上注册账号，获取AppKey及AppId，填到评论的js代码中。</p><p>最好再配置一下LeanCloud的安全域名，可以保证只有Blog的访问。</p><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>其实就是一些a标签，该主题自带，不过是Twitter、脸书及Google的，我自己照着加了一个微博的。代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">href</span>=<span class="string">"http://service.weibo.com/share/share.php?url=&lt;%- permalink %&gt;"</span> <span class="attr">onclick</span>=<span class="string">"window.open(this.href, 'weibo-share', 'width=550,height=235');return false;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span>Weibo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>似乎baidushare也很常用，但是……有点丑。</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>铛铛铛～ 终于到激动人心的时候了，上 vps/github.io!</p><h4 id="github-io"><a href="#github-io" class="headerlink" title="github.io"></a>github.io</h4><p>需要新建一个&lt;github-name&gt;.github.io 的仓库</p><p>使用git部署，需要先安装插件： <code>npm install hexo-deployer-git --save</code><br>修改config.yml中的deploy部分为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr"> - type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">   repo:</span> <span class="string">&lt;repo-name&gt;</span></span><br><span class="line"><span class="attr">   branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>之后执行<code>hexo deploy</code>部署到github上，即可通过仓库名访问。可以自行配置域名，在此不赘述。</p><h4 id="vps"><a href="#vps" class="headerlink" title="vps"></a>vps</h4><p>vps需要从 Vultr 或者 DigitalOcean 等供应商处租赁，常用的配置价格为5刀/月<br>部署其实也很简单…… 先安装一个Nginx，记得防火墙开启权限 步骤大致如下（Ubuntu）：<br>安装nginx <code>apt-get install nginx</code><br>防火墙允许 <code>ufw allow &quot;Nginx Full&quot;</code></p><p>然后配置一下nginx，使之能够显示博客站点<br>创建站点配置文件<code>vi /etc/nginx/conf.d/blog.conf</code>，内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen [::]:80;</span><br><span class="line">        root /var/www/blog/html;</span><br><span class="line">        index index.html index.htm index.nginx-debian.html;</span><br><span class="line">        server_name example.com www.example.com;</span><br><span class="line">        access_log /var/log/nginx/blog_access.log;</span><br><span class="line">        error_log /var/log/nginx/blog_error.log;</span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">        location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">          root /var/www/blog/html;</span><br><span class="line">          access_log   off;</span><br><span class="line">          expires      1d;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">          root /var/www/blog/html;</span><br><span class="line">          access_log   off;</span><br><span class="line">          expires      10m;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ =404;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改/etc/nginx/sites-available/default  <code>listen 80 default_server;</code>为<code>listen 80;</code><br>并在nginx中的http块中添加<code>include /etc/nginx/conf.d/*.conf;</code>和<code>include /etc/nginx/sites-enabled/*;</code>重启nginx并添加开机启动项。</p><p>之后配置git钩子 也就是一个空的git仓库，当本地的hexo推送给这个仓库时，会有个脚本执行自动拉取代码。<br><code>mkdir -p /var/www/blog/html</code>路径用于存放站点<br><code>git init --bare blog.git</code>创建空仓库<br><code>cd blog.git/hooks</code>准备创建钩子脚本<br><code>vi post-receive</code>创建脚本，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">git --work-tree=/var/www/blog/html --git-dir=/var/www/blog/html/blog.git checkout -f</span><br></pre></td></tr></table></figure><p>git checkout -f 会强制拉取代码</p><p>本地配置config.yml的deploy部分：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">   type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">   repo:</span> </span><br><span class="line"><span class="attr">   vps:</span> <span class="attr">ssh://&lt;username&gt;@&lt;ip&gt;:&lt;port&gt;/var/www/path/to/blog.git</span></span><br><span class="line"><span class="attr">   branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p><p>这种方式可以配置ssh的端口，其中的username需要可以免密登陆vps。</p><h2 id="404"><a href="#404" class="headerlink" title="404"></a>404</h2><p>首先需要创建一个自定义404页面，与about页相似 <code>hexo new page 404</code><br>修改Front-matter部分，layout为false，permalink为/404.html，comments为false</p><p>与/about不同，它会在根目录生成404.html而不是/404/index.html。填入内容即可</p><p>对于github pages：检测到根目录的404.html时，会将其作为404页面</p><p>对于nginx：修改站点conf，如blog.conf，添加error page条目error_page 404 /404.html;</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>如今，https也是博客标配了，这里我使用最方便的Let’s Encrypt方案，用其提供的certbot来自动签发证书。之后配合nginx配置https。<br>配置之前要确保80和443端口是打开的。debian使用的iptables，通过下两行命令实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br></pre></td></tr></table></figure></p><p>debian安装certbot，并按照提示配置:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install certbot python-certbot-nginx</span><br><span class="line">sudo certbot --nginx</span><br></pre></td></tr></table></figure></p><p>生成的证书在/etc/letsencrypt/live/$domain目录下。由于证书会在30天后过期，因此，需要使用cron脚本自动更新。如下：<br><code>0 3 15 * * root certbot renew &gt; /dev/null</code><br>每15天凌晨3点更新证书。</p><p>certbot在配置完成后，会自动修改你的&lt;server&gt;.conf文件，修改监听443端口并指定证书和私钥的位置。使用<code>nginx -s reload</code>使配置生效，此时访问就已经是https的方式了。</p><h2 id="Outro"><a href="#Outro" class="headerlink" title="Outro"></a>Outro</h2><p>一整天时间搭建Blog，基本达到心里预期，基本都很简明</p><p>后续还有SEO、Google Analysis及全站Https</p><p>在反复沮丧中坚持✊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引
      
    
    </summary>
    
    
      <category term="hexo, Blog" scheme="http://lavaoxsea.com/tags/hexo-Blog/"/>
    
  </entry>
  
</feed>
